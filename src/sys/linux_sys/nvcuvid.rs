use super::cuviddec::*;
use cudarc::driver::sys::*;
/* automatically generated by rust-bindgen 0.71.1 */

pub type wchar_t = ::core::ffi::c_int;
pub type CUvideosource = *mut ::core::ffi::c_void;
pub type CUvideoparser = *mut ::core::ffi::c_void;
pub type CUvideotimestamp = ::core::ffi::c_longlong;
pub type CUSEIMESSAGE = _CUSEIMESSAGE;
pub type CUVIDSEIMESSAGEINFO = _CUVIDSEIMESSAGEINFO;
pub type CUVIDSOURCEDATAPACKET = _CUVIDSOURCEDATAPACKET;
pub type PFNVIDSOURCECALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut CUVIDSOURCEDATAPACKET,
    ) -> ::core::ffi::c_int,
>;
pub type CUVIDSOURCEPARAMS = _CUVIDSOURCEPARAMS;
pub type CUVIDPARSERDISPINFO = _CUVIDPARSERDISPINFO;
pub type PFNVIDSEQUENCECALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut CUVIDEOFORMAT,
    ) -> ::core::ffi::c_int,
>;
pub type PFNVIDDECODECALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut CUVIDPICPARAMS,
    ) -> ::core::ffi::c_int,
>;
pub type PFNVIDDISPLAYCALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut CUVIDPARSERDISPINFO,
    ) -> ::core::ffi::c_int,
>;
pub type PFNVIDOPPOINTCALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut CUVIDOPERATINGPOINTINFO,
    ) -> ::core::ffi::c_int,
>;
pub type PFNVIDSEIMSGCALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut CUVIDSEIMESSAGEINFO,
    ) -> ::core::ffi::c_int,
>;
pub type CUVIDPARSERPARAMS = _CUVIDPARSERPARAMS;
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CUSEIMESSAGE {
    pub sei_message_type: ::core::ffi::c_uchar,
    pub reserved: [::core::ffi::c_uchar; 3usize],
    pub sei_message_size: ::core::ffi::c_uint,
}
#[repr(C)]
#[derive(Clone, Debug)]
pub struct CUVIDEOFORMAT {
    pub codec: cudaVideoCodec,
    pub frame_rate: CUVIDEOFORMAT__bindgen_ty_1,
    pub progressive_sequence: ::core::ffi::c_uchar,
    pub bit_depth_luma_minus8: ::core::ffi::c_uchar,
    pub bit_depth_chroma_minus8: ::core::ffi::c_uchar,
    pub min_num_decode_surfaces: ::core::ffi::c_uchar,
    pub coded_width: ::core::ffi::c_uint,
    pub coded_height: ::core::ffi::c_uint,
    pub display_area: CUVIDEOFORMAT__bindgen_ty_2,
    pub chroma_format: cudaVideoChromaFormat,
    pub bitrate: ::core::ffi::c_uint,
    pub display_aspect_ratio: CUVIDEOFORMAT__bindgen_ty_3,
    pub video_signal_description: CUVIDEOFORMAT__bindgen_ty_4,
    pub seqhdr_data_length: ::core::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_1 {
    pub numerator: ::core::ffi::c_uint,
    pub denominator: ::core::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_2 {
    pub left: ::core::ffi::c_int,
    pub top: ::core::ffi::c_int,
    pub right: ::core::ffi::c_int,
    pub bottom: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_3 {
    pub x: ::core::ffi::c_int,
    pub y: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_4 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub color_primaries: ::core::ffi::c_uchar,
    pub transfer_characteristics: ::core::ffi::c_uchar,
    pub matrix_coefficients: ::core::ffi::c_uchar,
}
#[repr(C)]
pub struct CUVIDOPERATINGPOINTINFO {
    pub codec: cudaVideoCodec,
    pub __bindgen_anon_1: CUVIDOPERATINGPOINTINFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1 {
    pub operating_points_cnt: ::core::ffi::c_uchar,
    pub reserved24_bits: [::core::ffi::c_uchar; 3usize],
    pub operating_points_idc: [::core::ffi::c_ushort; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CUVIDSEIMESSAGEINFO {
    pub pSEIData: *mut ::core::ffi::c_void,
    pub pSEIMessage: *mut CUSEIMESSAGE,
    pub sei_message_count: ::core::ffi::c_uint,
    pub picIdx: ::core::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUVIDAV1SEQHDR {
    pub max_width: ::core::ffi::c_uint,
    pub max_height: ::core::ffi::c_uint,
    pub reserved: [::core::ffi::c_uchar; 1016usize],
}
#[repr(C)]
pub struct CUVIDEOFORMATEX {
    pub format: CUVIDEOFORMAT,
    pub __bindgen_anon_1: CUVIDEOFORMATEX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUAUDIOFORMAT {
    pub codec: cudaAudioCodec,
    pub channels: ::core::ffi::c_uint,
    pub samplespersec: ::core::ffi::c_uint,
    pub bitrate: ::core::ffi::c_uint,
    pub reserved1: ::core::ffi::c_uint,
    pub reserved2: ::core::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CUVIDSOURCEDATAPACKET {
    pub flags: ::core::ffi::c_ulong,
    pub payload_size: ::core::ffi::c_ulong,
    pub payload: *const ::core::ffi::c_uchar,
    pub timestamp: CUvideotimestamp,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CUVIDSOURCEPARAMS {
    pub ulClockRate: ::core::ffi::c_uint,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub uReserved1: [::core::ffi::c_uint; 6usize],
    pub pUserData: *mut ::core::ffi::c_void,
    pub pfnVideoDataHandler: PFNVIDSOURCECALLBACK,
    pub pfnAudioDataHandler: PFNVIDSOURCECALLBACK,
    pub pvReserved2: [*mut ::core::ffi::c_void; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CUVIDPARSERDISPINFO {
    pub picture_index: ::core::ffi::c_int,
    pub progressive_frame: ::core::ffi::c_int,
    pub top_field_first: ::core::ffi::c_int,
    pub repeat_first_field: ::core::ffi::c_int,
    pub timestamp: CUvideotimestamp,
}
#[repr(C)]
pub struct _CUVIDPARSERPARAMS {
    pub CodecType: cudaVideoCodec,
    pub ulMaxNumDecodeSurfaces: ::core::ffi::c_uint,
    pub ulClockRate: ::core::ffi::c_uint,
    pub ulErrorThreshold: ::core::ffi::c_uint,
    pub ulMaxDisplayDelay: ::core::ffi::c_uint,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub uReserved1: [::core::ffi::c_uint; 4usize],
    pub pUserData: *mut ::core::ffi::c_void,
    pub pfnSequenceCallback: PFNVIDSEQUENCECALLBACK,
    pub pfnDecodePicture: PFNVIDDECODECALLBACK,
    pub pfnDisplayPicture: PFNVIDDISPLAYCALLBACK,
    pub pfnGetOperatingPoint: PFNVIDOPPOINTCALLBACK,
    pub pfnGetSEIMsg: PFNVIDSEIMSGCALLBACK,
    pub pvReserved2: [*mut ::core::ffi::c_void; 5usize],
    pub pExtVideoInfo: *mut CUVIDEOFORMATEX,
}
pub const MAX_CLOCK_TS: u32 = 3;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _CUSEIMESSAGE"][::core::mem::size_of::<_CUSEIMESSAGE>() - 8usize];
    ["Alignment of _CUSEIMESSAGE"][::core::mem::align_of::<_CUSEIMESSAGE>() - 4usize];
    ["Offset of field: _CUSEIMESSAGE::sei_message_type"]
        [::core::mem::offset_of!(_CUSEIMESSAGE, sei_message_type) - 0usize];
    ["Offset of field: _CUSEIMESSAGE::reserved"]
        [::core::mem::offset_of!(_CUSEIMESSAGE, reserved) - 1usize];
    ["Offset of field: _CUSEIMESSAGE::sei_message_size"]
        [::core::mem::offset_of!(_CUSEIMESSAGE, sei_message_size) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUVIDEOFORMAT__bindgen_ty_1"]
        [::core::mem::size_of::<CUVIDEOFORMAT__bindgen_ty_1>() - 8usize];
    ["Alignment of CUVIDEOFORMAT__bindgen_ty_1"]
        [::core::mem::align_of::<CUVIDEOFORMAT__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUVIDEOFORMAT__bindgen_ty_1::numerator"]
        [::core::mem::offset_of!(CUVIDEOFORMAT__bindgen_ty_1, numerator) - 0usize];
    ["Offset of field: CUVIDEOFORMAT__bindgen_ty_1::denominator"]
        [::core::mem::offset_of!(CUVIDEOFORMAT__bindgen_ty_1, denominator) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUVIDEOFORMAT__bindgen_ty_2"]
        [::core::mem::size_of::<CUVIDEOFORMAT__bindgen_ty_2>() - 16usize];
    ["Alignment of CUVIDEOFORMAT__bindgen_ty_2"]
        [::core::mem::align_of::<CUVIDEOFORMAT__bindgen_ty_2>() - 4usize];
    ["Offset of field: CUVIDEOFORMAT__bindgen_ty_2::left"]
        [::core::mem::offset_of!(CUVIDEOFORMAT__bindgen_ty_2, left) - 0usize];
    ["Offset of field: CUVIDEOFORMAT__bindgen_ty_2::top"]
        [::core::mem::offset_of!(CUVIDEOFORMAT__bindgen_ty_2, top) - 4usize];
    ["Offset of field: CUVIDEOFORMAT__bindgen_ty_2::right"]
        [::core::mem::offset_of!(CUVIDEOFORMAT__bindgen_ty_2, right) - 8usize];
    ["Offset of field: CUVIDEOFORMAT__bindgen_ty_2::bottom"]
        [::core::mem::offset_of!(CUVIDEOFORMAT__bindgen_ty_2, bottom) - 12usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUVIDEOFORMAT__bindgen_ty_3"]
        [::core::mem::size_of::<CUVIDEOFORMAT__bindgen_ty_3>() - 8usize];
    ["Alignment of CUVIDEOFORMAT__bindgen_ty_3"]
        [::core::mem::align_of::<CUVIDEOFORMAT__bindgen_ty_3>() - 4usize];
    ["Offset of field: CUVIDEOFORMAT__bindgen_ty_3::x"]
        [::core::mem::offset_of!(CUVIDEOFORMAT__bindgen_ty_3, x) - 0usize];
    ["Offset of field: CUVIDEOFORMAT__bindgen_ty_3::y"]
        [::core::mem::offset_of!(CUVIDEOFORMAT__bindgen_ty_3, y) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUVIDEOFORMAT__bindgen_ty_4"]
        [::core::mem::size_of::<CUVIDEOFORMAT__bindgen_ty_4>() - 4usize];
    ["Alignment of CUVIDEOFORMAT__bindgen_ty_4"]
        [::core::mem::align_of::<CUVIDEOFORMAT__bindgen_ty_4>() - 1usize];
    ["Offset of field: CUVIDEOFORMAT__bindgen_ty_4::color_primaries"]
        [::core::mem::offset_of!(CUVIDEOFORMAT__bindgen_ty_4, color_primaries) - 1usize];
    ["Offset of field: CUVIDEOFORMAT__bindgen_ty_4::transfer_characteristics"]
        [::core::mem::offset_of!(CUVIDEOFORMAT__bindgen_ty_4, transfer_characteristics) - 2usize];
    ["Offset of field: CUVIDEOFORMAT__bindgen_ty_4::matrix_coefficients"]
        [::core::mem::offset_of!(CUVIDEOFORMAT__bindgen_ty_4, matrix_coefficients) - 3usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUVIDEOFORMAT"][::core::mem::size_of::<CUVIDEOFORMAT>() - 64usize];
    ["Alignment of CUVIDEOFORMAT"][::core::mem::align_of::<CUVIDEOFORMAT>() - 4usize];
    ["Offset of field: CUVIDEOFORMAT::codec"]
        [::core::mem::offset_of!(CUVIDEOFORMAT, codec) - 0usize];
    ["Offset of field: CUVIDEOFORMAT::frame_rate"]
        [::core::mem::offset_of!(CUVIDEOFORMAT, frame_rate) - 4usize];
    ["Offset of field: CUVIDEOFORMAT::progressive_sequence"]
        [::core::mem::offset_of!(CUVIDEOFORMAT, progressive_sequence) - 12usize];
    ["Offset of field: CUVIDEOFORMAT::bit_depth_luma_minus8"]
        [::core::mem::offset_of!(CUVIDEOFORMAT, bit_depth_luma_minus8) - 13usize];
    ["Offset of field: CUVIDEOFORMAT::bit_depth_chroma_minus8"]
        [::core::mem::offset_of!(CUVIDEOFORMAT, bit_depth_chroma_minus8) - 14usize];
    ["Offset of field: CUVIDEOFORMAT::min_num_decode_surfaces"]
        [::core::mem::offset_of!(CUVIDEOFORMAT, min_num_decode_surfaces) - 15usize];
    ["Offset of field: CUVIDEOFORMAT::coded_width"]
        [::core::mem::offset_of!(CUVIDEOFORMAT, coded_width) - 16usize];
    ["Offset of field: CUVIDEOFORMAT::coded_height"]
        [::core::mem::offset_of!(CUVIDEOFORMAT, coded_height) - 20usize];
    ["Offset of field: CUVIDEOFORMAT::display_area"]
        [::core::mem::offset_of!(CUVIDEOFORMAT, display_area) - 24usize];
    ["Offset of field: CUVIDEOFORMAT::chroma_format"]
        [::core::mem::offset_of!(CUVIDEOFORMAT, chroma_format) - 40usize];
    ["Offset of field: CUVIDEOFORMAT::bitrate"]
        [::core::mem::offset_of!(CUVIDEOFORMAT, bitrate) - 44usize];
    ["Offset of field: CUVIDEOFORMAT::display_aspect_ratio"]
        [::core::mem::offset_of!(CUVIDEOFORMAT, display_aspect_ratio) - 48usize];
    ["Offset of field: CUVIDEOFORMAT::video_signal_description"]
        [::core::mem::offset_of!(CUVIDEOFORMAT, video_signal_description) - 56usize];
    ["Offset of field: CUVIDEOFORMAT::seqhdr_data_length"]
        [::core::mem::offset_of!(CUVIDEOFORMAT, seqhdr_data_length) - 60usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1>() - 68usize];
    ["Alignment of CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1>() - 2usize];
    ["Offset of field: CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1::operating_points_cnt"] [:: core :: mem :: offset_of ! (CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1 , operating_points_cnt) - 0usize] ;
    ["Offset of field: CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1::reserved24_bits"][::core::mem::offset_of!(
        CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1,
        reserved24_bits
    )
        - 1usize];
    ["Offset of field: CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1::operating_points_idc"] [:: core :: mem :: offset_of ! (CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1 , operating_points_idc) - 4usize] ;
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUVIDOPERATINGPOINTINFO__bindgen_ty_1"]
        [::core::mem::size_of::<CUVIDOPERATINGPOINTINFO__bindgen_ty_1>() - 1024usize];
    ["Alignment of CUVIDOPERATINGPOINTINFO__bindgen_ty_1"]
        [::core::mem::align_of::<CUVIDOPERATINGPOINTINFO__bindgen_ty_1>() - 2usize];
    ["Offset of field: CUVIDOPERATINGPOINTINFO__bindgen_ty_1::av1"]
        [::core::mem::offset_of!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1, av1) - 0usize];
    ["Offset of field: CUVIDOPERATINGPOINTINFO__bindgen_ty_1::CodecReserved"]
        [::core::mem::offset_of!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1, CodecReserved) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUVIDOPERATINGPOINTINFO"]
        [::core::mem::size_of::<CUVIDOPERATINGPOINTINFO>() - 1028usize];
    ["Alignment of CUVIDOPERATINGPOINTINFO"]
        [::core::mem::align_of::<CUVIDOPERATINGPOINTINFO>() - 4usize];
    ["Offset of field: CUVIDOPERATINGPOINTINFO::codec"]
        [::core::mem::offset_of!(CUVIDOPERATINGPOINTINFO, codec) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _CUVIDSEIMESSAGEINFO"][::core::mem::size_of::<_CUVIDSEIMESSAGEINFO>() - 24usize];
    ["Alignment of _CUVIDSEIMESSAGEINFO"][::core::mem::align_of::<_CUVIDSEIMESSAGEINFO>() - 8usize];
    ["Offset of field: _CUVIDSEIMESSAGEINFO::pSEIData"]
        [::core::mem::offset_of!(_CUVIDSEIMESSAGEINFO, pSEIData) - 0usize];
    ["Offset of field: _CUVIDSEIMESSAGEINFO::pSEIMessage"]
        [::core::mem::offset_of!(_CUVIDSEIMESSAGEINFO, pSEIMessage) - 8usize];
    ["Offset of field: _CUVIDSEIMESSAGEINFO::sei_message_count"]
        [::core::mem::offset_of!(_CUVIDSEIMESSAGEINFO, sei_message_count) - 16usize];
    ["Offset of field: _CUVIDSEIMESSAGEINFO::picIdx"]
        [::core::mem::offset_of!(_CUVIDSEIMESSAGEINFO, picIdx) - 20usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUVIDAV1SEQHDR"][::core::mem::size_of::<CUVIDAV1SEQHDR>() - 1024usize];
    ["Alignment of CUVIDAV1SEQHDR"][::core::mem::align_of::<CUVIDAV1SEQHDR>() - 4usize];
    ["Offset of field: CUVIDAV1SEQHDR::max_width"]
        [::core::mem::offset_of!(CUVIDAV1SEQHDR, max_width) - 0usize];
    ["Offset of field: CUVIDAV1SEQHDR::max_height"]
        [::core::mem::offset_of!(CUVIDAV1SEQHDR, max_height) - 4usize];
    ["Offset of field: CUVIDAV1SEQHDR::reserved"]
        [::core::mem::offset_of!(CUVIDAV1SEQHDR, reserved) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUVIDEOFORMATEX__bindgen_ty_1"]
        [::core::mem::size_of::<CUVIDEOFORMATEX__bindgen_ty_1>() - 1024usize];
    ["Alignment of CUVIDEOFORMATEX__bindgen_ty_1"]
        [::core::mem::align_of::<CUVIDEOFORMATEX__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUVIDEOFORMATEX__bindgen_ty_1::av1"]
        [::core::mem::offset_of!(CUVIDEOFORMATEX__bindgen_ty_1, av1) - 0usize];
    ["Offset of field: CUVIDEOFORMATEX__bindgen_ty_1::raw_seqhdr_data"]
        [::core::mem::offset_of!(CUVIDEOFORMATEX__bindgen_ty_1, raw_seqhdr_data) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUVIDEOFORMATEX"][::core::mem::size_of::<CUVIDEOFORMATEX>() - 1088usize];
    ["Alignment of CUVIDEOFORMATEX"][::core::mem::align_of::<CUVIDEOFORMATEX>() - 4usize];
    ["Offset of field: CUVIDEOFORMATEX::format"]
        [::core::mem::offset_of!(CUVIDEOFORMATEX, format) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUAUDIOFORMAT"][::core::mem::size_of::<CUAUDIOFORMAT>() - 24usize];
    ["Alignment of CUAUDIOFORMAT"][::core::mem::align_of::<CUAUDIOFORMAT>() - 4usize];
    ["Offset of field: CUAUDIOFORMAT::codec"]
        [::core::mem::offset_of!(CUAUDIOFORMAT, codec) - 0usize];
    ["Offset of field: CUAUDIOFORMAT::channels"]
        [::core::mem::offset_of!(CUAUDIOFORMAT, channels) - 4usize];
    ["Offset of field: CUAUDIOFORMAT::samplespersec"]
        [::core::mem::offset_of!(CUAUDIOFORMAT, samplespersec) - 8usize];
    ["Offset of field: CUAUDIOFORMAT::bitrate"]
        [::core::mem::offset_of!(CUAUDIOFORMAT, bitrate) - 12usize];
    ["Offset of field: CUAUDIOFORMAT::reserved1"]
        [::core::mem::offset_of!(CUAUDIOFORMAT, reserved1) - 16usize];
    ["Offset of field: CUAUDIOFORMAT::reserved2"]
        [::core::mem::offset_of!(CUAUDIOFORMAT, reserved2) - 20usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _CUVIDSOURCEDATAPACKET"][::core::mem::size_of::<_CUVIDSOURCEDATAPACKET>() - 32usize];
    ["Alignment of _CUVIDSOURCEDATAPACKET"]
        [::core::mem::align_of::<_CUVIDSOURCEDATAPACKET>() - 8usize];
    ["Offset of field: _CUVIDSOURCEDATAPACKET::flags"]
        [::core::mem::offset_of!(_CUVIDSOURCEDATAPACKET, flags) - 0usize];
    ["Offset of field: _CUVIDSOURCEDATAPACKET::payload_size"]
        [::core::mem::offset_of!(_CUVIDSOURCEDATAPACKET, payload_size) - 8usize];
    ["Offset of field: _CUVIDSOURCEDATAPACKET::payload"]
        [::core::mem::offset_of!(_CUVIDSOURCEDATAPACKET, payload) - 16usize];
    ["Offset of field: _CUVIDSOURCEDATAPACKET::timestamp"]
        [::core::mem::offset_of!(_CUVIDSOURCEDATAPACKET, timestamp) - 24usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _CUVIDSOURCEPARAMS"][::core::mem::size_of::<_CUVIDSOURCEPARAMS>() - 120usize];
    ["Alignment of _CUVIDSOURCEPARAMS"][::core::mem::align_of::<_CUVIDSOURCEPARAMS>() - 8usize];
    ["Offset of field: _CUVIDSOURCEPARAMS::ulClockRate"]
        [::core::mem::offset_of!(_CUVIDSOURCEPARAMS, ulClockRate) - 0usize];
    ["Offset of field: _CUVIDSOURCEPARAMS::uReserved1"]
        [::core::mem::offset_of!(_CUVIDSOURCEPARAMS, uReserved1) - 8usize];
    ["Offset of field: _CUVIDSOURCEPARAMS::pUserData"]
        [::core::mem::offset_of!(_CUVIDSOURCEPARAMS, pUserData) - 32usize];
    ["Offset of field: _CUVIDSOURCEPARAMS::pfnVideoDataHandler"]
        [::core::mem::offset_of!(_CUVIDSOURCEPARAMS, pfnVideoDataHandler) - 40usize];
    ["Offset of field: _CUVIDSOURCEPARAMS::pfnAudioDataHandler"]
        [::core::mem::offset_of!(_CUVIDSOURCEPARAMS, pfnAudioDataHandler) - 48usize];
    ["Offset of field: _CUVIDSOURCEPARAMS::pvReserved2"]
        [::core::mem::offset_of!(_CUVIDSOURCEPARAMS, pvReserved2) - 56usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _CUVIDPARSERDISPINFO"][::core::mem::size_of::<_CUVIDPARSERDISPINFO>() - 24usize];
    ["Alignment of _CUVIDPARSERDISPINFO"][::core::mem::align_of::<_CUVIDPARSERDISPINFO>() - 8usize];
    ["Offset of field: _CUVIDPARSERDISPINFO::picture_index"]
        [::core::mem::offset_of!(_CUVIDPARSERDISPINFO, picture_index) - 0usize];
    ["Offset of field: _CUVIDPARSERDISPINFO::progressive_frame"]
        [::core::mem::offset_of!(_CUVIDPARSERDISPINFO, progressive_frame) - 4usize];
    ["Offset of field: _CUVIDPARSERDISPINFO::top_field_first"]
        [::core::mem::offset_of!(_CUVIDPARSERDISPINFO, top_field_first) - 8usize];
    ["Offset of field: _CUVIDPARSERDISPINFO::repeat_first_field"]
        [::core::mem::offset_of!(_CUVIDPARSERDISPINFO, repeat_first_field) - 12usize];
    ["Offset of field: _CUVIDPARSERDISPINFO::timestamp"]
        [::core::mem::offset_of!(_CUVIDPARSERDISPINFO, timestamp) - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _CUVIDPARSERPARAMS"][::core::mem::size_of::<_CUVIDPARSERPARAMS>() - 136usize];
    ["Alignment of _CUVIDPARSERPARAMS"][::core::mem::align_of::<_CUVIDPARSERPARAMS>() - 8usize];
    ["Offset of field: _CUVIDPARSERPARAMS::CodecType"]
        [::core::mem::offset_of!(_CUVIDPARSERPARAMS, CodecType) - 0usize];
    ["Offset of field: _CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces"]
        [::core::mem::offset_of!(_CUVIDPARSERPARAMS, ulMaxNumDecodeSurfaces) - 4usize];
    ["Offset of field: _CUVIDPARSERPARAMS::ulClockRate"]
        [::core::mem::offset_of!(_CUVIDPARSERPARAMS, ulClockRate) - 8usize];
    ["Offset of field: _CUVIDPARSERPARAMS::ulErrorThreshold"]
        [::core::mem::offset_of!(_CUVIDPARSERPARAMS, ulErrorThreshold) - 12usize];
    ["Offset of field: _CUVIDPARSERPARAMS::ulMaxDisplayDelay"]
        [::core::mem::offset_of!(_CUVIDPARSERPARAMS, ulMaxDisplayDelay) - 16usize];
    ["Offset of field: _CUVIDPARSERPARAMS::uReserved1"]
        [::core::mem::offset_of!(_CUVIDPARSERPARAMS, uReserved1) - 24usize];
    ["Offset of field: _CUVIDPARSERPARAMS::pUserData"]
        [::core::mem::offset_of!(_CUVIDPARSERPARAMS, pUserData) - 40usize];
    ["Offset of field: _CUVIDPARSERPARAMS::pfnSequenceCallback"]
        [::core::mem::offset_of!(_CUVIDPARSERPARAMS, pfnSequenceCallback) - 48usize];
    ["Offset of field: _CUVIDPARSERPARAMS::pfnDecodePicture"]
        [::core::mem::offset_of!(_CUVIDPARSERPARAMS, pfnDecodePicture) - 56usize];
    ["Offset of field: _CUVIDPARSERPARAMS::pfnDisplayPicture"]
        [::core::mem::offset_of!(_CUVIDPARSERPARAMS, pfnDisplayPicture) - 64usize];
    ["Offset of field: _CUVIDPARSERPARAMS::pfnGetOperatingPoint"]
        [::core::mem::offset_of!(_CUVIDPARSERPARAMS, pfnGetOperatingPoint) - 72usize];
    ["Offset of field: _CUVIDPARSERPARAMS::pfnGetSEIMsg"]
        [::core::mem::offset_of!(_CUVIDPARSERPARAMS, pfnGetSEIMsg) - 80usize];
    ["Offset of field: _CUVIDPARSERPARAMS::pvReserved2"]
        [::core::mem::offset_of!(_CUVIDPARSERPARAMS, pvReserved2) - 88usize];
    ["Offset of field: _CUVIDPARSERPARAMS::pExtVideoInfo"]
        [::core::mem::offset_of!(_CUVIDPARSERPARAMS, pExtVideoInfo) - 128usize];
};
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum cudaVideoState {
    cudaVideoState_Error = -1,
    cudaVideoState_Stopped = 0,
    cudaVideoState_Started = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum cudaAudioCodec {
    cudaAudioCodec_MPEG1 = 0,
    cudaAudioCodec_MPEG2 = 1,
    cudaAudioCodec_MP3 = 2,
    cudaAudioCodec_AC3 = 3,
    cudaAudioCodec_LPCM = 4,
    cudaAudioCodec_AAC = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUvideopacketflags {
    CUVID_PKT_ENDOFSTREAM = 1,
    CUVID_PKT_TIMESTAMP = 2,
    CUVID_PKT_DISCONTINUITY = 4,
    CUVID_PKT_ENDOFPICTURE = 8,
    CUVID_PKT_NOTIFY_EOS = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUvideosourceformat_flags {
    CUVID_FMT_EXTFORMATINFO = 256,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUVIDOPERATINGPOINTINFO__bindgen_ty_1 {
    pub av1: CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1,
    pub CodecReserved: [::core::ffi::c_uchar; 1024usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUVIDEOFORMATEX__bindgen_ty_1 {
    pub av1: CUVIDAV1SEQHDR,
    pub raw_seqhdr_data: [::core::ffi::c_uchar; 1024usize],
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
impl CUVIDEOFORMAT__bindgen_ty_4 {
    #[inline]
    pub fn video_format(&self) -> ::core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_video_format(&mut self, val: ::core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn video_format_raw(this: *const Self) -> ::core::ffi::c_uchar {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_video_format_raw(this: *mut Self, val: ::core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn video_full_range_flag(&self) -> ::core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_video_full_range_flag(&mut self, val: ::core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn video_full_range_flag_raw(this: *const Self) -> ::core::ffi::c_uchar {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_video_full_range_flag_raw(this: *mut Self, val: ::core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_zero_bits(&self) -> ::core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved_zero_bits(&mut self, val: ::core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_zero_bits_raw(this: *const Self) -> ::core::ffi::c_uchar {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_zero_bits_raw(this: *mut Self, val: ::core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        video_format: ::core::ffi::c_uchar,
        video_full_range_flag: ::core::ffi::c_uchar,
        reserved_zero_bits: ::core::ffi::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let video_format: u8 = unsafe { ::core::mem::transmute(video_format) };
            video_format as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let video_full_range_flag: u8 =
                unsafe { ::core::mem::transmute(video_full_range_flag) };
            video_full_range_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved_zero_bits: u8 = unsafe { ::core::mem::transmute(reserved_zero_bits) };
            reserved_zero_bits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for CUVIDEOFORMAT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUVIDOPERATINGPOINTINFO__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUVIDOPERATINGPOINTINFO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CUVIDSEIMESSAGEINFO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUVIDAV1SEQHDR {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUVIDEOFORMATEX__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUVIDEOFORMATEX {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUAUDIOFORMAT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CUVIDSOURCEDATAPACKET {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CUVIDSOURCEPARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CUVIDSOURCEPARAMS {
    #[inline]
    pub fn bAnnexb(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bAnnexb(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bAnnexb_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bAnnexb_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn uReserved(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_uReserved(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uReserved_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_uReserved_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bAnnexb: ::core::ffi::c_uint,
        uReserved: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bAnnexb: u32 = unsafe { ::core::mem::transmute(bAnnexb) };
            bAnnexb as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let uReserved: u32 = unsafe { ::core::mem::transmute(uReserved) };
            uReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _CUVIDPARSERPARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CUVIDPARSERPARAMS {
    #[inline]
    pub fn bAnnexb(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bAnnexb(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bAnnexb_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bAnnexb_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bMemoryOptimize(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bMemoryOptimize(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bMemoryOptimize_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bMemoryOptimize_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn uReserved(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_uReserved(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uReserved_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_uReserved_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bAnnexb: ::core::ffi::c_uint,
        bMemoryOptimize: ::core::ffi::c_uint,
        uReserved: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bAnnexb: u32 = unsafe { ::core::mem::transmute(bAnnexb) };
            bAnnexb as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bMemoryOptimize: u32 = unsafe { ::core::mem::transmute(bMemoryOptimize) };
            bMemoryOptimize as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let uReserved: u32 = unsafe { ::core::mem::transmute(uReserved) };
            uReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    #[must_use]
    pub fn cuvidCreateVideoSource(
        pObj: *mut CUvideosource,
        pszFileName: *const ::core::ffi::c_char,
        pParams: *mut CUVIDSOURCEPARAMS,
    ) -> CUresult;
    #[must_use]
    pub fn cuvidCreateVideoSourceW(
        pObj: *mut CUvideosource,
        pwszFileName: *const wchar_t,
        pParams: *mut CUVIDSOURCEPARAMS,
    ) -> CUresult;
    #[must_use]
    pub fn cuvidDestroyVideoSource(obj: CUvideosource) -> CUresult;
    #[must_use]
    pub fn cuvidSetVideoSourceState(obj: CUvideosource, state: cudaVideoState) -> CUresult;
    pub fn cuvidGetVideoSourceState(obj: CUvideosource) -> cudaVideoState;
    #[must_use]
    pub fn cuvidGetSourceVideoFormat(
        obj: CUvideosource,
        pvidfmt: *mut CUVIDEOFORMAT,
        flags: ::core::ffi::c_uint,
    ) -> CUresult;
    #[must_use]
    pub fn cuvidGetSourceAudioFormat(
        obj: CUvideosource,
        paudfmt: *mut CUAUDIOFORMAT,
        flags: ::core::ffi::c_uint,
    ) -> CUresult;
    #[must_use]
    pub fn cuvidCreateVideoParser(
        pObj: *mut CUvideoparser,
        pParams: *mut CUVIDPARSERPARAMS,
    ) -> CUresult;
    #[must_use]
    pub fn cuvidParseVideoData(obj: CUvideoparser, pPacket: *mut CUVIDSOURCEDATAPACKET)
        -> CUresult;
    #[must_use]
    pub fn cuvidDestroyVideoParser(obj: CUvideoparser) -> CUresult;
}
