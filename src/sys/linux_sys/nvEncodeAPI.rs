pub use super::super::version::*;
pub use super::super::guid::*;
/* automatically generated by rust-bindgen 0.71.1 */

pub type GUID = _GUID;
pub type NVENC_RECT = _NVENC_RECT;
pub type NV_ENC_INPUT_PTR = *mut ::core::ffi::c_void;
pub type NV_ENC_OUTPUT_PTR = *mut ::core::ffi::c_void;
pub type NV_ENC_REGISTERED_PTR = *mut ::core::ffi::c_void;
pub type NV_ENC_CUSTREAM_PTR = *mut ::core::ffi::c_void;
pub type NV_ENC_CAPS_PARAM = _NV_ENC_CAPS_PARAM;
pub type NV_ENC_RESTORE_ENCODER_STATE_PARAMS = _NV_ENC_RESTORE_ENCODER_STATE_PARAMS;
pub type NV_ENC_OUTPUT_STATS_BLOCK = _NV_ENC_OUTPUT_STATS_BLOCK;
pub type NV_ENC_OUTPUT_STATS_ROW = _NV_ENC_OUTPUT_STATS_ROW;
pub type NV_ENC_ENCODE_OUT_PARAMS = _NV_ENC_ENCODE_OUT_PARAMS;
pub type NV_ENC_LOOKAHEAD_PIC_PARAMS = _NV_ENC_LOOKAHEAD_PIC_PARAMS;
pub type NV_ENC_CREATE_INPUT_BUFFER = _NV_ENC_CREATE_INPUT_BUFFER;
pub type NV_ENC_CREATE_BITSTREAM_BUFFER = _NV_ENC_CREATE_BITSTREAM_BUFFER;
pub type NV_ENC_MVECTOR = _NV_ENC_MVECTOR;
pub type NV_ENC_H264_MV_DATA = _NV_ENC_H264_MV_DATA;
pub type NV_ENC_HEVC_MV_DATA = _NV_ENC_HEVC_MV_DATA;
pub type NV_ENC_CREATE_MV_BUFFER = _NV_ENC_CREATE_MV_BUFFER;
pub type NV_ENC_QP = _NV_ENC_QP;
pub type NV_ENC_RC_PARAMS = _NV_ENC_RC_PARAMS;
pub type NV_ENC_CLOCK_TIMESTAMP_SET = _NV_ENC_CLOCK_TIMESTAMP_SET;
pub type NV_ENC_TIME_CODE = _NV_ENC_TIME_CODE;
pub type HEVC_3D_REFERENCE_DISPLAY_INFO = _HEVC_3D_REFERENCE_DISPLAY_INFO;
pub type CHROMA_POINTS = _CHROMA_POINTS;
pub type MASTERING_DISPLAY_INFO = _MASTERING_DISPLAY_INFO;
pub type CONTENT_LIGHT_LEVEL = _CONTENT_LIGHT_LEVEL;
pub type NV_ENC_CONFIG_H264_VUI_PARAMETERS = _NV_ENC_CONFIG_H264_VUI_PARAMETERS;
pub type NV_ENC_CONFIG_HEVC_VUI_PARAMETERS = NV_ENC_CONFIG_H264_VUI_PARAMETERS;
pub type NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE = _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE;
pub type NVENC_EXTERNAL_ME_HINT = _NVENC_EXTERNAL_ME_HINT;
pub type NVENC_EXTERNAL_ME_SB_HINT = _NVENC_EXTERNAL_ME_SB_HINT;
pub type NV_ENC_CONFIG_H264 = _NV_ENC_CONFIG_H264;
pub type NV_ENC_CONFIG_HEVC = _NV_ENC_CONFIG_HEVC;
pub type NV_ENC_FILM_GRAIN_PARAMS_AV1 = _NV_ENC_FILM_GRAIN_PARAMS_AV1;
pub type NV_ENC_CONFIG_AV1 = _NV_ENC_CONFIG_AV1;
pub type NV_ENC_CONFIG_H264_MEONLY = _NV_ENC_CONFIG_H264_MEONLY;
pub type NV_ENC_CONFIG_HEVC_MEONLY = _NV_ENC_CONFIG_HEVC_MEONLY;
pub type NV_ENC_CODEC_CONFIG = _NV_ENC_CODEC_CONFIG;
pub type NV_ENC_CONFIG = _NV_ENC_CONFIG;
pub type NV_ENC_INITIALIZE_PARAMS = _NV_ENC_INITIALIZE_PARAMS;
pub type NV_ENC_RECONFIGURE_PARAMS = _NV_ENC_RECONFIGURE_PARAMS;
pub type NV_ENC_PRESET_CONFIG = _NV_ENC_PRESET_CONFIG;
pub type NV_ENC_PIC_PARAMS_MVC = _NV_ENC_PIC_PARAMS_MVC;
pub type NV_ENC_PIC_PARAMS_H264_EXT = _NV_ENC_PIC_PARAMS_H264_EXT;
pub type NV_ENC_SEI_PAYLOAD = _NV_ENC_SEI_PAYLOAD;
pub type NV_ENC_PIC_PARAMS_H264 = _NV_ENC_PIC_PARAMS_H264;
pub type NV_ENC_PIC_PARAMS_HEVC = _NV_ENC_PIC_PARAMS_HEVC;
pub type NV_ENC_PIC_PARAMS_AV1 = _NV_ENC_PIC_PARAMS_AV1;
pub type NV_ENC_CODEC_PIC_PARAMS = _NV_ENC_CODEC_PIC_PARAMS;
pub type NV_ENC_PIC_PARAMS = _NV_ENC_PIC_PARAMS;
pub type NV_ENC_MEONLY_PARAMS = _NV_ENC_MEONLY_PARAMS;
pub type NV_ENC_LOCK_BITSTREAM = _NV_ENC_LOCK_BITSTREAM;
pub type NV_ENC_LOCK_INPUT_BUFFER = _NV_ENC_LOCK_INPUT_BUFFER;
pub type NV_ENC_MAP_INPUT_RESOURCE = _NV_ENC_MAP_INPUT_RESOURCE;
pub type NV_ENC_INPUT_RESOURCE_OPENGL_TEX = _NV_ENC_INPUT_RESOURCE_OPENGL_TEX;
pub type NV_ENC_FENCE_POINT_D3D12 = _NV_ENC_FENCE_POINT_D3D12;
pub type NV_ENC_INPUT_RESOURCE_D3D12 = _NV_ENC_INPUT_RESOURCE_D3D12;
pub type NV_ENC_OUTPUT_RESOURCE_D3D12 = _NV_ENC_OUTPUT_RESOURCE_D3D12;
pub type NV_ENC_REGISTER_RESOURCE = _NV_ENC_REGISTER_RESOURCE;
pub type NV_ENC_STAT = _NV_ENC_STAT;
pub type NV_ENC_SEQUENCE_PARAM_PAYLOAD = _NV_ENC_SEQUENCE_PARAM_PAYLOAD;
pub type NV_ENC_EVENT_PARAMS = _NV_ENC_EVENT_PARAMS;
pub type NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS = _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS;
pub type PNVENCOPENENCODESESSION = ::core::option::Option<
    unsafe extern "C" fn(
        device: *mut ::core::ffi::c_void,
        deviceType: u32,
        encoder: *mut *mut ::core::ffi::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDCOUNT = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        GUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPROFILEGUIDCOUNT = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        encodeProfileGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPROFILEGUIDS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        profileGUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATCOUNT = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        inputFmts: *mut NV_ENC_BUFFER_FORMAT,
        inputFmtArraySize: u32,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODECAPS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        capsParam: *mut NV_ENC_CAPS_PARAM,
        capsVal: *mut ::core::ffi::c_int,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCOUNT = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETGUIDS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        presetGUIDs: *mut GUID,
        guidArraySize: u32,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCONFIG = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCONFIGEX = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        tuningInfo: NV_ENC_TUNING_INFO,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS,
>;
pub type PNVENCINITIALIZEENCODER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        createEncodeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEINPUTBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        createInputBufferParams: *mut NV_ENC_CREATE_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYINPUTBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEBITSTREAMBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        createBitstreamBufferParams: *mut NV_ENC_CREATE_BITSTREAM_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYBITSTREAMBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCENCODEPICTURE = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodePicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKBITSTREAM = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        lockBitstreamBufferParams: *mut NV_ENC_LOCK_BITSTREAM,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKBITSTREAM = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKINPUTBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        lockInputBufferParams: *mut NV_ENC_LOCK_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKINPUTBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODESTATS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeStats: *mut NV_ENC_STAT,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETSEQUENCEPARAMS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERASYNCEVENT = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERASYNCEVENT = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCMAPINPUTRESOURCE = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        mapInputResParams: *mut NV_ENC_MAP_INPUT_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNMAPINPUTRESOURCE = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        mappedInputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYENCODER =
    ::core::option::Option<unsafe extern "C" fn(encoder: *mut ::core::ffi::c_void) -> NVENCSTATUS>;
pub type PNVENCINVALIDATEREFFRAMES = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        invalidRefFrameTimeStamp: u64,
    ) -> NVENCSTATUS,
>;
pub type PNVENCOPENENCODESESSIONEX = ::core::option::Option<
    unsafe extern "C" fn(
        openSessionExParams: *mut NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS,
        encoder: *mut *mut ::core::ffi::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERRESOURCE = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        registerResParams: *mut NV_ENC_REGISTER_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERRESOURCE = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        registeredRes: NV_ENC_REGISTERED_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRECONFIGUREENCODER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        reInitEncodeParams: *mut NV_ENC_RECONFIGURE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEMVBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        createMVBufferParams: *mut NV_ENC_CREATE_MV_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYMVBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        mvBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRUNMOTIONESTIMATIONONLY = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        meOnlyParams: *mut NV_ENC_MEONLY_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETLASTERROR = ::core::option::Option<
    unsafe extern "C" fn(encoder: *mut ::core::ffi::c_void) -> *const ::core::ffi::c_char,
>;
pub type PNVENCSETIOCUDASTREAMS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        inputStream: NV_ENC_CUSTREAM_PTR,
        outputStream: NV_ENC_CUSTREAM_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETSEQUENCEPARAMEX = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encInitParams: *mut NV_ENC_INITIALIZE_PARAMS,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRESTOREENCODERSTATE = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        restoreState: *mut NV_ENC_RESTORE_ENCODER_STATE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOOKAHEADPICTURE = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        lookaheadParams: *mut NV_ENC_LOOKAHEAD_PIC_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type NV_ENCODE_API_FUNCTION_LIST = _NV_ENCODE_API_FUNCTION_LIST;
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _GUID {
    pub Data1: u32,
    pub Data2: u16,
    pub Data3: u16,
    pub Data4: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NVENC_RECT {
    pub left: u32,
    pub top: u32,
    pub right: u32,
    pub bottom: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CAPS_PARAM {
    pub version: u32,
    pub capsToQuery: NV_ENC_CAPS,
    pub reserved: [u32; 62usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_RESTORE_ENCODER_STATE_PARAMS {
    pub version: u32,
    pub bufferIdx: u32,
    pub state: NV_ENC_STATE_RESTORE_TYPE,
    pub reserved: u32,
    pub outputBitstream: NV_ENC_OUTPUT_PTR,
    pub completionEvent: *mut ::core::ffi::c_void,
    pub reserved1: [u32; 64usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_OUTPUT_STATS_BLOCK {
    pub version: u32,
    pub QP: u8,
    pub reserved: [u8; 3usize],
    pub bitcount: u32,
    pub satdCost: u32,
    pub reserved1: [u32; 12usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_OUTPUT_STATS_ROW {
    pub version: u32,
    pub QP: u8,
    pub reserved: [u8; 3usize],
    pub bitcount: u32,
    pub satdCost: u32,
    pub reserved1: [u32; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_ENCODE_OUT_PARAMS {
    pub version: u32,
    pub bitstreamSizeInBytes: u32,
    pub reserved: [u32; 62usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_LOOKAHEAD_PIC_PARAMS {
    pub version: u32,
    pub reserved: u32,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub pictureType: NV_ENC_PIC_TYPE,
    pub reserved1: [u32; 63usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_INPUT_BUFFER {
    pub version: u32,
    pub width: u32,
    pub height: u32,
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    pub reserved: u32,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub pSysMemBuffer: *mut ::core::ffi::c_void,
    pub reserved1: [u32; 58usize],
    pub reserved2: [*mut ::core::ffi::c_void; 63usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_BITSTREAM_BUFFER {
    pub version: u32,
    pub size: u32,
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    pub reserved: u32,
    pub bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    pub bitstreamBufferPtr: *mut ::core::ffi::c_void,
    pub reserved1: [u32; 58usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_MVECTOR {
    pub mvx: i16,
    pub mvy: i16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_H264_MV_DATA {
    pub mv: [NV_ENC_MVECTOR; 4usize],
    pub mbType: u8,
    pub partitionType: u8,
    pub reserved: u16,
    pub mbCost: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_HEVC_MV_DATA {
    pub mv: [NV_ENC_MVECTOR; 4usize],
    pub cuType: u8,
    pub cuSize: u8,
    pub partitionMode: u8,
    pub lastCUInCTB: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_MV_BUFFER {
    pub version: u32,
    pub reserved: u32,
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    pub reserved1: [u32; 254usize],
    pub reserved2: [*mut ::core::ffi::c_void; 63usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_QP {
    pub qpInterP: u32,
    pub qpInterB: u32,
    pub qpIntra: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_RC_PARAMS {
    pub version: u32,
    pub rateControlMode: NV_ENC_PARAMS_RC_MODE,
    pub constQP: NV_ENC_QP,
    pub averageBitRate: u32,
    pub maxBitRate: u32,
    pub vbvBufferSize: u32,
    pub vbvInitialDelay: u32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub minQP: NV_ENC_QP,
    pub maxQP: NV_ENC_QP,
    pub initialRCQP: NV_ENC_QP,
    pub temporallayerIdxMask: u32,
    pub temporalLayerQP: [u8; 8usize],
    pub targetQuality: u8,
    pub targetQualityLSB: u8,
    pub lookaheadDepth: u16,
    pub lowDelayKeyFrameScale: u8,
    pub yDcQPIndexOffset: i8,
    pub uDcQPIndexOffset: i8,
    pub vDcQPIndexOffset: i8,
    pub qpMapMode: NV_ENC_QP_MAP_MODE,
    pub multiPass: NV_ENC_MULTI_PASS,
    pub alphaLayerBitrateRatio: u32,
    pub cbQPIndexOffset: i8,
    pub crQPIndexOffset: i8,
    pub reserved2: u16,
    pub lookaheadLevel: NV_ENC_LOOKAHEAD_LEVEL,
    pub viewBitrateRatios: [u8; 7usize],
    pub reserved3: u8,
    pub reserved1: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CLOCK_TIMESTAMP_SET {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub timeOffset: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_TIME_CODE {
    pub displayPicStruct: NV_ENC_DISPLAY_PIC_STRUCT,
    pub clockTimestamp: [NV_ENC_CLOCK_TIMESTAMP_SET; 3usize],
    pub skipClockTimestampInsertion: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEVC_3D_REFERENCE_DISPLAY_INFO {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub precRefDisplayWidth: i32,
    pub precRefViewingDist: i32,
    pub numRefDisplaysMinus1: i32,
    pub leftViewId: [i32; 32usize],
    pub rightViewId: [i32; 32usize],
    pub exponentRefDisplayWidth: [i32; 32usize],
    pub mantissaRefDisplayWidth: [i32; 32usize],
    pub exponentRefViewingDistance: [i32; 32usize],
    pub mantissaRefViewingDistance: [i32; 32usize],
    pub numSampleShiftPlus512: [i32; 32usize],
    pub additionalShiftPresentFlag: [u8; 32usize],
    pub reserved2: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CHROMA_POINTS {
    pub x: u16,
    pub y: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _MASTERING_DISPLAY_INFO {
    pub g: CHROMA_POINTS,
    pub b: CHROMA_POINTS,
    pub r: CHROMA_POINTS,
    pub whitePoint: CHROMA_POINTS,
    pub maxLuma: u32,
    pub minLuma: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CONTENT_LIGHT_LEVEL {
    pub maxContentLightLevel: u16,
    pub maxPicAverageLightLevel: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS {
    pub overscanInfoPresentFlag: u32,
    pub overscanInfo: u32,
    pub videoSignalTypePresentFlag: u32,
    pub videoFormat: NV_ENC_VUI_VIDEO_FORMAT,
    pub videoFullRangeFlag: u32,
    pub colourDescriptionPresentFlag: u32,
    pub colourPrimaries: NV_ENC_VUI_COLOR_PRIMARIES,
    pub transferCharacteristics: NV_ENC_VUI_TRANSFER_CHARACTERISTIC,
    pub colourMatrix: NV_ENC_VUI_MATRIX_COEFFS,
    pub chromaSampleLocationFlag: u32,
    pub chromaSampleLocationTop: u32,
    pub chromaSampleLocationBot: u32,
    pub bitstreamRestrictionFlag: u32,
    pub timingInfoPresentFlag: u32,
    pub numUnitInTicks: u32,
    pub timeScale: u32,
    pub reserved: [u32; 12usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: [u32; 3usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_HINT {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_SB_HINT {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub level: u32,
    pub idrPeriod: u32,
    pub separateColourPlaneFlag: u32,
    pub disableDeblockingFilterIDC: u32,
    pub numTemporalLayers: u32,
    pub spsId: u32,
    pub ppsId: u32,
    pub adaptiveTransformMode: NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE,
    pub fmoMode: NV_ENC_H264_FMO_MODE,
    pub bdirectMode: NV_ENC_H264_BDIRECT_MODE,
    pub entropyCodingMode: NV_ENC_H264_ENTROPY_CODING_MODE,
    pub stereoMode: NV_ENC_STEREO_PACKING_MODE,
    pub intraRefreshPeriod: u32,
    pub intraRefreshCnt: u32,
    pub maxNumRefFrames: u32,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub h264VUIParameters: NV_ENC_CONFIG_H264_VUI_PARAMETERS,
    pub ltrNumFrames: u32,
    pub ltrTrustMode: u32,
    pub chromaFormatIDC: u32,
    pub maxTemporalLayers: u32,
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    pub numRefL0: NV_ENC_NUM_REF_FRAMES,
    pub numRefL1: NV_ENC_NUM_REF_FRAMES,
    pub outputBitDepth: NV_ENC_BIT_DEPTH,
    pub inputBitDepth: NV_ENC_BIT_DEPTH,
    pub tfLevel: NV_ENC_TEMPORAL_FILTER_LEVEL,
    pub reserved1: [u32; 264usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_HEVC {
    pub level: u32,
    pub tier: u32,
    pub minCUSize: NV_ENC_HEVC_CUSIZE,
    pub maxCUSize: NV_ENC_HEVC_CUSIZE,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub idrPeriod: u32,
    pub intraRefreshPeriod: u32,
    pub intraRefreshCnt: u32,
    pub maxNumRefFramesInDPB: u32,
    pub ltrNumFrames: u32,
    pub vpsId: u32,
    pub spsId: u32,
    pub ppsId: u32,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub maxTemporalLayersMinus1: u32,
    pub hevcVUIParameters: NV_ENC_CONFIG_HEVC_VUI_PARAMETERS,
    pub ltrTrustMode: u32,
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    pub numRefL0: NV_ENC_NUM_REF_FRAMES,
    pub numRefL1: NV_ENC_NUM_REF_FRAMES,
    pub tfLevel: NV_ENC_TEMPORAL_FILTER_LEVEL,
    pub disableDeblockingFilterIDC: u32,
    pub outputBitDepth: NV_ENC_BIT_DEPTH,
    pub inputBitDepth: NV_ENC_BIT_DEPTH,
    pub numTemporalLayers: u32,
    pub numViews: u32,
    pub reserved1: [u32; 208usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_FILM_GRAIN_PARAMS_AV1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub pointYValue: [u8; 14usize],
    pub pointYScaling: [u8; 14usize],
    pub pointCbValue: [u8; 10usize],
    pub pointCbScaling: [u8; 10usize],
    pub pointCrValue: [u8; 10usize],
    pub pointCrScaling: [u8; 10usize],
    pub arCoeffsYPlus128: [u8; 24usize],
    pub arCoeffsCbPlus128: [u8; 25usize],
    pub arCoeffsCrPlus128: [u8; 25usize],
    pub reserved2: [u8; 2usize],
    pub cbMult: u8,
    pub cbLumaMult: u8,
    pub cbOffset: u16,
    pub crMult: u8,
    pub crLumaMult: u8,
    pub crOffset: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_AV1 {
    pub level: u32,
    pub tier: u32,
    pub minPartSize: NV_ENC_AV1_PART_SIZE,
    pub maxPartSize: NV_ENC_AV1_PART_SIZE,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub idrPeriod: u32,
    pub intraRefreshPeriod: u32,
    pub intraRefreshCnt: u32,
    pub maxNumRefFramesInDPB: u32,
    pub numTileColumns: u32,
    pub numTileRows: u32,
    pub reserved2: u32,
    pub tileWidths: *mut u32,
    pub tileHeights: *mut u32,
    pub maxTemporalLayersMinus1: u32,
    pub colorPrimaries: NV_ENC_VUI_COLOR_PRIMARIES,
    pub transferCharacteristics: NV_ENC_VUI_TRANSFER_CHARACTERISTIC,
    pub matrixCoefficients: NV_ENC_VUI_MATRIX_COEFFS,
    pub colorRange: u32,
    pub chromaSamplePosition: u32,
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    pub filmGrainParams: *mut NV_ENC_FILM_GRAIN_PARAMS_AV1,
    pub numFwdRefs: NV_ENC_NUM_REF_FRAMES,
    pub numBwdRefs: NV_ENC_NUM_REF_FRAMES,
    pub outputBitDepth: NV_ENC_BIT_DEPTH,
    pub inputBitDepth: NV_ENC_BIT_DEPTH,
    pub ltrNumFrames: u32,
    pub numTemporalLayers: u32,
    pub tfLevel: NV_ENC_TEMPORAL_FILTER_LEVEL,
    pub reserved1: [u32; 230usize],
    pub reserved3: [*mut ::core::ffi::c_void; 62usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264_MEONLY {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: [u32; 255usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_HEVC_MEONLY {
    pub reserved: [u32; 256usize],
    pub reserved1: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG {
    pub version: u32,
    pub profileGUID: GUID,
    pub gopLength: u32,
    pub frameIntervalP: i32,
    pub monoChromeEncoding: u32,
    pub frameFieldMode: NV_ENC_PARAMS_FRAME_FIELD_MODE,
    pub mvPrecision: NV_ENC_MV_PRECISION,
    pub rcParams: NV_ENC_RC_PARAMS,
    pub encodeCodecConfig: NV_ENC_CODEC_CONFIG,
    pub reserved: [u32; 278usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_INITIALIZE_PARAMS {
    pub version: u32,
    pub encodeGUID: GUID,
    pub presetGUID: GUID,
    pub encodeWidth: u32,
    pub encodeHeight: u32,
    pub darWidth: u32,
    pub darHeight: u32,
    pub frameRateNum: u32,
    pub frameRateDen: u32,
    pub enableEncodeAsync: u32,
    pub enablePTD: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub privDataSize: u32,
    pub reserved: u32,
    pub privData: *mut ::core::ffi::c_void,
    pub encodeConfig: *mut NV_ENC_CONFIG,
    pub maxEncodeWidth: u32,
    pub maxEncodeHeight: u32,
    pub maxMEHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    pub tuningInfo: NV_ENC_TUNING_INFO,
    pub bufferFormat: NV_ENC_BUFFER_FORMAT,
    pub numStateBuffers: u32,
    pub outputStatsLevel: NV_ENC_OUTPUT_STATS_LEVEL,
    pub reserved1: [u32; 284usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_RECONFIGURE_PARAMS {
    pub version: u32,
    pub reserved: u32,
    pub reInitEncodeParams: NV_ENC_INITIALIZE_PARAMS,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved2: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PRESET_CONFIG {
    pub version: u32,
    pub reserved: u32,
    pub presetCfg: NV_ENC_CONFIG,
    pub reserved1: [u32; 256usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_PIC_PARAMS_MVC {
    pub version: u32,
    pub viewID: u32,
    pub temporalID: u32,
    pub priorityID: u32,
    pub reserved1: [u32; 12usize],
    pub reserved2: [*mut ::core::ffi::c_void; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_SEI_PAYLOAD {
    pub payloadSize: u32,
    pub payloadType: u32,
    pub payload: *mut u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS_H264 {
    pub displayPOCSyntax: u32,
    pub reserved3: u32,
    pub refPicFlag: u32,
    pub colourPlaneId: u32,
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sliceTypeData: *mut u8,
    pub sliceTypeArrayCnt: u32,
    pub seiPayloadArrayCnt: u32,
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub ltrMarkFrameIdx: u32,
    pub ltrUseFrameBitmap: u32,
    pub ltrUsageMode: u32,
    pub forceIntraSliceCount: u32,
    pub forceIntraSliceIdx: *mut u32,
    pub h264ExtPicParams: NV_ENC_PIC_PARAMS_H264_EXT,
    pub timeCode: NV_ENC_TIME_CODE,
    pub reserved: [u32; 202usize],
    pub reserved2: [*mut ::core::ffi::c_void; 61usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_PIC_PARAMS_HEVC {
    pub displayPOCSyntax: u32,
    pub refPicFlag: u32,
    pub temporalId: u32,
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: u32,
    pub sliceTypeData: *mut u8,
    pub sliceTypeArrayCnt: u32,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub ltrMarkFrameIdx: u32,
    pub ltrUseFrameBitmap: u32,
    pub ltrUsageMode: u32,
    pub seiPayloadArrayCnt: u32,
    pub reserved: u32,
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    pub timeCode: NV_ENC_TIME_CODE,
    pub numTemporalLayers: u32,
    pub viewId: u32,
    pub p3DReferenceDisplayInfo: *mut HEVC_3D_REFERENCE_DISPLAY_INFO,
    pub pMaxCll: *mut CONTENT_LIGHT_LEVEL,
    pub pMasteringDisplay: *mut MASTERING_DISPLAY_INFO,
    pub reserved2: [u32; 234usize],
    pub reserved3: [*mut ::core::ffi::c_void; 58usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_PIC_PARAMS_AV1 {
    pub displayPOCSyntax: u32,
    pub refPicFlag: u32,
    pub temporalId: u32,
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub numTileColumns: u32,
    pub numTileRows: u32,
    pub reserved: u32,
    pub tileWidths: *mut u32,
    pub tileHeights: *mut u32,
    pub obuPayloadArrayCnt: u32,
    pub reserved1: u32,
    pub obuPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    pub filmGrainParams: *mut NV_ENC_FILM_GRAIN_PARAMS_AV1,
    pub ltrMarkFrameIdx: u32,
    pub ltrUseFrameBitmap: u32,
    pub numTemporalLayers: u32,
    pub reserved4: u32,
    pub pMaxCll: *mut CONTENT_LIGHT_LEVEL,
    pub pMasteringDisplay: *mut MASTERING_DISPLAY_INFO,
    pub reserved2: [u32; 242usize],
    pub reserved3: [*mut ::core::ffi::c_void; 59usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS {
    pub version: u32,
    pub inputWidth: u32,
    pub inputHeight: u32,
    pub inputPitch: u32,
    pub encodePicFlags: u32,
    pub frameIdx: u32,
    pub inputTimeStamp: u64,
    pub inputDuration: u64,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub outputBitstream: NV_ENC_OUTPUT_PTR,
    pub completionEvent: *mut ::core::ffi::c_void,
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    pub pictureType: NV_ENC_PIC_TYPE,
    pub codecPicParams: NV_ENC_CODEC_PIC_PARAMS,
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    pub reserved2: [u32; 7usize],
    pub reserved5: [*mut ::core::ffi::c_void; 2usize],
    pub qpDeltaMap: *mut i8,
    pub qpDeltaMapSize: u32,
    pub reservedBitFields: u32,
    pub meHintRefPicDist: [u16; 2usize],
    pub reserved4: u32,
    pub alphaBuffer: NV_ENC_INPUT_PTR,
    pub meExternalSbHints: *mut NVENC_EXTERNAL_ME_SB_HINT,
    pub meSbHintsCount: u32,
    pub stateBufferIdx: u32,
    pub outputReconBuffer: NV_ENC_OUTPUT_PTR,
    pub reserved3: [u32; 284usize],
    pub reserved6: [*mut ::core::ffi::c_void; 57usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_MEONLY_PARAMS {
    pub version: u32,
    pub inputWidth: u32,
    pub inputHeight: u32,
    pub reserved: u32,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub referenceFrame: NV_ENC_INPUT_PTR,
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    pub reserved2: u32,
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    pub completionEvent: *mut ::core::ffi::c_void,
    pub viewID: u32,
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    pub reserved1: [u32; 241usize],
    pub reserved3: [*mut ::core::ffi::c_void; 59usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_LOCK_BITSTREAM {
    pub version: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub outputBitstream: *mut ::core::ffi::c_void,
    pub sliceOffsets: *mut u32,
    pub frameIdx: u32,
    pub hwEncodeStatus: u32,
    pub numSlices: u32,
    pub bitstreamSizeInBytes: u32,
    pub outputTimeStamp: u64,
    pub outputDuration: u64,
    pub bitstreamBufferPtr: *mut ::core::ffi::c_void,
    pub pictureType: NV_ENC_PIC_TYPE,
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    pub frameAvgQP: u32,
    pub frameSatd: u32,
    pub ltrFrameIdx: u32,
    pub ltrFrameBitmap: u32,
    pub temporalId: u32,
    pub intraMBCount: u32,
    pub interMBCount: u32,
    pub averageMVX: i32,
    pub averageMVY: i32,
    pub alphaLayerSizeInBytes: u32,
    pub outputStatsPtrSize: u32,
    pub reserved: u32,
    pub outputStatsPtr: *mut ::core::ffi::c_void,
    pub frameIdxDisplay: u32,
    pub reserved1: [u32; 219usize],
    pub reserved2: [*mut ::core::ffi::c_void; 63usize],
    pub reservedInternal: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_LOCK_INPUT_BUFFER {
    pub version: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub bufferDataPtr: *mut ::core::ffi::c_void,
    pub pitch: u32,
    pub reserved1: [u32; 251usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_MAP_INPUT_RESOURCE {
    pub version: u32,
    pub subResourceIndex: u32,
    pub inputResource: *mut ::core::ffi::c_void,
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    pub mappedResource: NV_ENC_INPUT_PTR,
    pub mappedBufferFmt: NV_ENC_BUFFER_FORMAT,
    pub reserved1: [u32; 251usize],
    pub reserved2: [*mut ::core::ffi::c_void; 63usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_INPUT_RESOURCE_OPENGL_TEX {
    pub texture: u32,
    pub target: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_FENCE_POINT_D3D12 {
    pub version: u32,
    pub reserved: u32,
    pub pFence: *mut ::core::ffi::c_void,
    pub waitValue: u64,
    pub signalValue: u64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: [u32; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_INPUT_RESOURCE_D3D12 {
    pub version: u32,
    pub reserved: u32,
    pub pInputBuffer: NV_ENC_INPUT_PTR,
    pub inputFencePoint: NV_ENC_FENCE_POINT_D3D12,
    pub reserved1: [u32; 16usize],
    pub reserved2: [*mut ::core::ffi::c_void; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_OUTPUT_RESOURCE_D3D12 {
    pub version: u32,
    pub reserved: u32,
    pub pOutputBuffer: NV_ENC_INPUT_PTR,
    pub outputFencePoint: NV_ENC_FENCE_POINT_D3D12,
    pub reserved1: [u32; 16usize],
    pub reserved2: [*mut ::core::ffi::c_void; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_REGISTER_RESOURCE {
    pub version: u32,
    pub resourceType: NV_ENC_INPUT_RESOURCE_TYPE,
    pub width: u32,
    pub height: u32,
    pub pitch: u32,
    pub subResourceIndex: u32,
    pub resourceToRegister: *mut ::core::ffi::c_void,
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    pub bufferFormat: NV_ENC_BUFFER_FORMAT,
    pub bufferUsage: NV_ENC_BUFFER_USAGE,
    pub pInputFencePoint: *mut NV_ENC_FENCE_POINT_D3D12,
    pub chromaOffset: [u32; 2usize],
    pub chromaOffsetIn: [u32; 2usize],
    pub reserved1: [u32; 244usize],
    pub reserved2: [*mut ::core::ffi::c_void; 61usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_STAT {
    pub version: u32,
    pub reserved: u32,
    pub outputBitStream: NV_ENC_OUTPUT_PTR,
    pub bitStreamSize: u32,
    pub picType: u32,
    pub lastValidByteOffset: u32,
    pub sliceOffsets: [u32; 16usize],
    pub picIdx: u32,
    pub frameAvgQP: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub ltrFrameIdx: u32,
    pub intraMBCount: u32,
    pub interMBCount: u32,
    pub averageMVX: i32,
    pub averageMVY: i32,
    pub reserved1: [u32; 227usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD {
    pub version: u32,
    pub inBufferSize: u32,
    pub spsId: u32,
    pub ppsId: u32,
    pub spsppsBuffer: *mut ::core::ffi::c_void,
    pub outSPSPPSPayloadSize: *mut u32,
    pub reserved: [u32; 250usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_EVENT_PARAMS {
    pub version: u32,
    pub reserved: u32,
    pub completionEvent: *mut ::core::ffi::c_void,
    pub reserved1: [u32; 254usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS {
    pub version: u32,
    pub deviceType: NV_ENC_DEVICE_TYPE,
    pub device: *mut ::core::ffi::c_void,
    pub reserved: *mut ::core::ffi::c_void,
    pub apiVersion: u32,
    pub reserved1: [u32; 253usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENCODE_API_FUNCTION_LIST {
    pub version: u32,
    pub reserved: u32,
    pub nvEncOpenEncodeSession: PNVENCOPENENCODESESSION,
    pub nvEncGetEncodeGUIDCount: PNVENCGETENCODEGUIDCOUNT,
    pub nvEncGetEncodeProfileGUIDCount: PNVENCGETENCODEPROFILEGUIDCOUNT,
    pub nvEncGetEncodeProfileGUIDs: PNVENCGETENCODEPROFILEGUIDS,
    pub nvEncGetEncodeGUIDs: PNVENCGETENCODEGUIDS,
    pub nvEncGetInputFormatCount: PNVENCGETINPUTFORMATCOUNT,
    pub nvEncGetInputFormats: PNVENCGETINPUTFORMATS,
    pub nvEncGetEncodeCaps: PNVENCGETENCODECAPS,
    pub nvEncGetEncodePresetCount: PNVENCGETENCODEPRESETCOUNT,
    pub nvEncGetEncodePresetGUIDs: PNVENCGETENCODEPRESETGUIDS,
    pub nvEncGetEncodePresetConfig: PNVENCGETENCODEPRESETCONFIG,
    pub nvEncInitializeEncoder: PNVENCINITIALIZEENCODER,
    pub nvEncCreateInputBuffer: PNVENCCREATEINPUTBUFFER,
    pub nvEncDestroyInputBuffer: PNVENCDESTROYINPUTBUFFER,
    pub nvEncCreateBitstreamBuffer: PNVENCCREATEBITSTREAMBUFFER,
    pub nvEncDestroyBitstreamBuffer: PNVENCDESTROYBITSTREAMBUFFER,
    pub nvEncEncodePicture: PNVENCENCODEPICTURE,
    pub nvEncLockBitstream: PNVENCLOCKBITSTREAM,
    pub nvEncUnlockBitstream: PNVENCUNLOCKBITSTREAM,
    pub nvEncLockInputBuffer: PNVENCLOCKINPUTBUFFER,
    pub nvEncUnlockInputBuffer: PNVENCUNLOCKINPUTBUFFER,
    pub nvEncGetEncodeStats: PNVENCGETENCODESTATS,
    pub nvEncGetSequenceParams: PNVENCGETSEQUENCEPARAMS,
    pub nvEncRegisterAsyncEvent: PNVENCREGISTERASYNCEVENT,
    pub nvEncUnregisterAsyncEvent: PNVENCUNREGISTERASYNCEVENT,
    pub nvEncMapInputResource: PNVENCMAPINPUTRESOURCE,
    pub nvEncUnmapInputResource: PNVENCUNMAPINPUTRESOURCE,
    pub nvEncDestroyEncoder: PNVENCDESTROYENCODER,
    pub nvEncInvalidateRefFrames: PNVENCINVALIDATEREFFRAMES,
    pub nvEncOpenEncodeSessionEx: PNVENCOPENENCODESESSIONEX,
    pub nvEncRegisterResource: PNVENCREGISTERRESOURCE,
    pub nvEncUnregisterResource: PNVENCUNREGISTERRESOURCE,
    pub nvEncReconfigureEncoder: PNVENCRECONFIGUREENCODER,
    pub reserved1: *mut ::core::ffi::c_void,
    pub nvEncCreateMVBuffer: PNVENCCREATEMVBUFFER,
    pub nvEncDestroyMVBuffer: PNVENCDESTROYMVBUFFER,
    pub nvEncRunMotionEstimationOnly: PNVENCRUNMOTIONESTIMATIONONLY,
    pub nvEncGetLastErrorString: PNVENCGETLASTERROR,
    pub nvEncSetIOCudaStreams: PNVENCSETIOCUDASTREAMS,
    pub nvEncGetEncodePresetConfigEx: PNVENCGETENCODEPRESETCONFIGEX,
    pub nvEncGetSequenceParamEx: PNVENCGETSEQUENCEPARAMEX,
    pub nvEncRestoreEncoderState: PNVENCRESTOREENCODERSTATE,
    pub nvEncLookaheadPicture: PNVENCLOOKAHEADPICTURE,
    pub reserved2: [*mut ::core::ffi::c_void; 275usize],
}
pub const NVENCAPI_MAJOR_VERSION: u32 = 13;
pub const NVENCAPI_MINOR_VERSION: u32 = 0;
pub const NVENCAPI_VERSION: u32 = 13;
pub const NVENC_INFINITE_GOPLENGTH: u32 = 4294967295;
pub const NV_MAX_SEQ_HDR_LEN: u32 = 512;
pub const NV_MAX_TILE_COLS_AV1: u32 = 64;
pub const NV_MAX_TILE_ROWS_AV1: u32 = 64;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GUID"][::core::mem::size_of::<_GUID>() - 16usize];
    ["Alignment of _GUID"][::core::mem::align_of::<_GUID>() - 4usize];
    ["Offset of field: _GUID::Data1"][::core::mem::offset_of!(_GUID, Data1) - 0usize];
    ["Offset of field: _GUID::Data2"][::core::mem::offset_of!(_GUID, Data2) - 4usize];
    ["Offset of field: _GUID::Data3"][::core::mem::offset_of!(_GUID, Data3) - 6usize];
    ["Offset of field: _GUID::Data4"][::core::mem::offset_of!(_GUID, Data4) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NVENC_RECT"][::core::mem::size_of::<_NVENC_RECT>() - 16usize];
    ["Alignment of _NVENC_RECT"][::core::mem::align_of::<_NVENC_RECT>() - 4usize];
    ["Offset of field: _NVENC_RECT::left"][::core::mem::offset_of!(_NVENC_RECT, left) - 0usize];
    ["Offset of field: _NVENC_RECT::top"][::core::mem::offset_of!(_NVENC_RECT, top) - 4usize];
    ["Offset of field: _NVENC_RECT::right"][::core::mem::offset_of!(_NVENC_RECT, right) - 8usize];
    ["Offset of field: _NVENC_RECT::bottom"]
        [::core::mem::offset_of!(_NVENC_RECT, bottom) - 12usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_CAPS_PARAM"][::core::mem::size_of::<_NV_ENC_CAPS_PARAM>() - 256usize];
    ["Alignment of _NV_ENC_CAPS_PARAM"][::core::mem::align_of::<_NV_ENC_CAPS_PARAM>() - 4usize];
    ["Offset of field: _NV_ENC_CAPS_PARAM::version"]
        [::core::mem::offset_of!(_NV_ENC_CAPS_PARAM, version) - 0usize];
    ["Offset of field: _NV_ENC_CAPS_PARAM::capsToQuery"]
        [::core::mem::offset_of!(_NV_ENC_CAPS_PARAM, capsToQuery) - 4usize];
    ["Offset of field: _NV_ENC_CAPS_PARAM::reserved"]
        [::core::mem::offset_of!(_NV_ENC_CAPS_PARAM, reserved) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_RESTORE_ENCODER_STATE_PARAMS"]
        [::core::mem::size_of::<_NV_ENC_RESTORE_ENCODER_STATE_PARAMS>() - 800usize];
    ["Alignment of _NV_ENC_RESTORE_ENCODER_STATE_PARAMS"]
        [::core::mem::align_of::<_NV_ENC_RESTORE_ENCODER_STATE_PARAMS>() - 8usize];
    ["Offset of field: _NV_ENC_RESTORE_ENCODER_STATE_PARAMS::version"]
        [::core::mem::offset_of!(_NV_ENC_RESTORE_ENCODER_STATE_PARAMS, version) - 0usize];
    ["Offset of field: _NV_ENC_RESTORE_ENCODER_STATE_PARAMS::bufferIdx"]
        [::core::mem::offset_of!(_NV_ENC_RESTORE_ENCODER_STATE_PARAMS, bufferIdx) - 4usize];
    ["Offset of field: _NV_ENC_RESTORE_ENCODER_STATE_PARAMS::state"]
        [::core::mem::offset_of!(_NV_ENC_RESTORE_ENCODER_STATE_PARAMS, state) - 8usize];
    ["Offset of field: _NV_ENC_RESTORE_ENCODER_STATE_PARAMS::reserved"]
        [::core::mem::offset_of!(_NV_ENC_RESTORE_ENCODER_STATE_PARAMS, reserved) - 12usize];
    ["Offset of field: _NV_ENC_RESTORE_ENCODER_STATE_PARAMS::outputBitstream"]
        [::core::mem::offset_of!(_NV_ENC_RESTORE_ENCODER_STATE_PARAMS, outputBitstream) - 16usize];
    ["Offset of field: _NV_ENC_RESTORE_ENCODER_STATE_PARAMS::completionEvent"]
        [::core::mem::offset_of!(_NV_ENC_RESTORE_ENCODER_STATE_PARAMS, completionEvent) - 24usize];
    ["Offset of field: _NV_ENC_RESTORE_ENCODER_STATE_PARAMS::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_RESTORE_ENCODER_STATE_PARAMS, reserved1) - 32usize];
    ["Offset of field: _NV_ENC_RESTORE_ENCODER_STATE_PARAMS::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_RESTORE_ENCODER_STATE_PARAMS, reserved2) - 288usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_OUTPUT_STATS_BLOCK"]
        [::core::mem::size_of::<_NV_ENC_OUTPUT_STATS_BLOCK>() - 64usize];
    ["Alignment of _NV_ENC_OUTPUT_STATS_BLOCK"]
        [::core::mem::align_of::<_NV_ENC_OUTPUT_STATS_BLOCK>() - 4usize];
    ["Offset of field: _NV_ENC_OUTPUT_STATS_BLOCK::version"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_STATS_BLOCK, version) - 0usize];
    ["Offset of field: _NV_ENC_OUTPUT_STATS_BLOCK::QP"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_STATS_BLOCK, QP) - 4usize];
    ["Offset of field: _NV_ENC_OUTPUT_STATS_BLOCK::reserved"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_STATS_BLOCK, reserved) - 5usize];
    ["Offset of field: _NV_ENC_OUTPUT_STATS_BLOCK::bitcount"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_STATS_BLOCK, bitcount) - 8usize];
    ["Offset of field: _NV_ENC_OUTPUT_STATS_BLOCK::satdCost"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_STATS_BLOCK, satdCost) - 12usize];
    ["Offset of field: _NV_ENC_OUTPUT_STATS_BLOCK::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_STATS_BLOCK, reserved1) - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_OUTPUT_STATS_ROW"]
        [::core::mem::size_of::<_NV_ENC_OUTPUT_STATS_ROW>() - 64usize];
    ["Alignment of _NV_ENC_OUTPUT_STATS_ROW"]
        [::core::mem::align_of::<_NV_ENC_OUTPUT_STATS_ROW>() - 4usize];
    ["Offset of field: _NV_ENC_OUTPUT_STATS_ROW::version"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_STATS_ROW, version) - 0usize];
    ["Offset of field: _NV_ENC_OUTPUT_STATS_ROW::QP"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_STATS_ROW, QP) - 4usize];
    ["Offset of field: _NV_ENC_OUTPUT_STATS_ROW::reserved"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_STATS_ROW, reserved) - 5usize];
    ["Offset of field: _NV_ENC_OUTPUT_STATS_ROW::bitcount"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_STATS_ROW, bitcount) - 8usize];
    ["Offset of field: _NV_ENC_OUTPUT_STATS_ROW::satdCost"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_STATS_ROW, satdCost) - 12usize];
    ["Offset of field: _NV_ENC_OUTPUT_STATS_ROW::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_STATS_ROW, reserved1) - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_ENCODE_OUT_PARAMS"]
        [::core::mem::size_of::<_NV_ENC_ENCODE_OUT_PARAMS>() - 256usize];
    ["Alignment of _NV_ENC_ENCODE_OUT_PARAMS"]
        [::core::mem::align_of::<_NV_ENC_ENCODE_OUT_PARAMS>() - 4usize];
    ["Offset of field: _NV_ENC_ENCODE_OUT_PARAMS::version"]
        [::core::mem::offset_of!(_NV_ENC_ENCODE_OUT_PARAMS, version) - 0usize];
    ["Offset of field: _NV_ENC_ENCODE_OUT_PARAMS::bitstreamSizeInBytes"]
        [::core::mem::offset_of!(_NV_ENC_ENCODE_OUT_PARAMS, bitstreamSizeInBytes) - 4usize];
    ["Offset of field: _NV_ENC_ENCODE_OUT_PARAMS::reserved"]
        [::core::mem::offset_of!(_NV_ENC_ENCODE_OUT_PARAMS, reserved) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_LOOKAHEAD_PIC_PARAMS"]
        [::core::mem::size_of::<_NV_ENC_LOOKAHEAD_PIC_PARAMS>() - 784usize];
    ["Alignment of _NV_ENC_LOOKAHEAD_PIC_PARAMS"]
        [::core::mem::align_of::<_NV_ENC_LOOKAHEAD_PIC_PARAMS>() - 8usize];
    ["Offset of field: _NV_ENC_LOOKAHEAD_PIC_PARAMS::version"]
        [::core::mem::offset_of!(_NV_ENC_LOOKAHEAD_PIC_PARAMS, version) - 0usize];
    ["Offset of field: _NV_ENC_LOOKAHEAD_PIC_PARAMS::reserved"]
        [::core::mem::offset_of!(_NV_ENC_LOOKAHEAD_PIC_PARAMS, reserved) - 4usize];
    ["Offset of field: _NV_ENC_LOOKAHEAD_PIC_PARAMS::inputBuffer"]
        [::core::mem::offset_of!(_NV_ENC_LOOKAHEAD_PIC_PARAMS, inputBuffer) - 8usize];
    ["Offset of field: _NV_ENC_LOOKAHEAD_PIC_PARAMS::pictureType"]
        [::core::mem::offset_of!(_NV_ENC_LOOKAHEAD_PIC_PARAMS, pictureType) - 16usize];
    ["Offset of field: _NV_ENC_LOOKAHEAD_PIC_PARAMS::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_LOOKAHEAD_PIC_PARAMS, reserved1) - 20usize];
    ["Offset of field: _NV_ENC_LOOKAHEAD_PIC_PARAMS::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_LOOKAHEAD_PIC_PARAMS, reserved2) - 272usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_CREATE_INPUT_BUFFER"]
        [::core::mem::size_of::<_NV_ENC_CREATE_INPUT_BUFFER>() - 776usize];
    ["Alignment of _NV_ENC_CREATE_INPUT_BUFFER"]
        [::core::mem::align_of::<_NV_ENC_CREATE_INPUT_BUFFER>() - 8usize];
    ["Offset of field: _NV_ENC_CREATE_INPUT_BUFFER::version"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_INPUT_BUFFER, version) - 0usize];
    ["Offset of field: _NV_ENC_CREATE_INPUT_BUFFER::width"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_INPUT_BUFFER, width) - 4usize];
    ["Offset of field: _NV_ENC_CREATE_INPUT_BUFFER::height"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_INPUT_BUFFER, height) - 8usize];
    ["Offset of field: _NV_ENC_CREATE_INPUT_BUFFER::memoryHeap"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_INPUT_BUFFER, memoryHeap) - 12usize];
    ["Offset of field: _NV_ENC_CREATE_INPUT_BUFFER::bufferFmt"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_INPUT_BUFFER, bufferFmt) - 16usize];
    ["Offset of field: _NV_ENC_CREATE_INPUT_BUFFER::reserved"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_INPUT_BUFFER, reserved) - 20usize];
    ["Offset of field: _NV_ENC_CREATE_INPUT_BUFFER::inputBuffer"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_INPUT_BUFFER, inputBuffer) - 24usize];
    ["Offset of field: _NV_ENC_CREATE_INPUT_BUFFER::pSysMemBuffer"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_INPUT_BUFFER, pSysMemBuffer) - 32usize];
    ["Offset of field: _NV_ENC_CREATE_INPUT_BUFFER::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_INPUT_BUFFER, reserved1) - 40usize];
    ["Offset of field: _NV_ENC_CREATE_INPUT_BUFFER::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_INPUT_BUFFER, reserved2) - 272usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_CREATE_BITSTREAM_BUFFER"]
        [::core::mem::size_of::<_NV_ENC_CREATE_BITSTREAM_BUFFER>() - 776usize];
    ["Alignment of _NV_ENC_CREATE_BITSTREAM_BUFFER"]
        [::core::mem::align_of::<_NV_ENC_CREATE_BITSTREAM_BUFFER>() - 8usize];
    ["Offset of field: _NV_ENC_CREATE_BITSTREAM_BUFFER::version"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_BITSTREAM_BUFFER, version) - 0usize];
    ["Offset of field: _NV_ENC_CREATE_BITSTREAM_BUFFER::size"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_BITSTREAM_BUFFER, size) - 4usize];
    ["Offset of field: _NV_ENC_CREATE_BITSTREAM_BUFFER::memoryHeap"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_BITSTREAM_BUFFER, memoryHeap) - 8usize];
    ["Offset of field: _NV_ENC_CREATE_BITSTREAM_BUFFER::reserved"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_BITSTREAM_BUFFER, reserved) - 12usize];
    ["Offset of field: _NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreamBuffer"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_BITSTREAM_BUFFER, bitstreamBuffer) - 16usize];
    ["Offset of field: _NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreamBufferPtr"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_BITSTREAM_BUFFER, bitstreamBufferPtr) - 24usize];
    ["Offset of field: _NV_ENC_CREATE_BITSTREAM_BUFFER::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_BITSTREAM_BUFFER, reserved1) - 32usize];
    ["Offset of field: _NV_ENC_CREATE_BITSTREAM_BUFFER::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_BITSTREAM_BUFFER, reserved2) - 264usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_MVECTOR"][::core::mem::size_of::<_NV_ENC_MVECTOR>() - 4usize];
    ["Alignment of _NV_ENC_MVECTOR"][::core::mem::align_of::<_NV_ENC_MVECTOR>() - 2usize];
    ["Offset of field: _NV_ENC_MVECTOR::mvx"]
        [::core::mem::offset_of!(_NV_ENC_MVECTOR, mvx) - 0usize];
    ["Offset of field: _NV_ENC_MVECTOR::mvy"]
        [::core::mem::offset_of!(_NV_ENC_MVECTOR, mvy) - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_H264_MV_DATA"][::core::mem::size_of::<_NV_ENC_H264_MV_DATA>() - 24usize];
    ["Alignment of _NV_ENC_H264_MV_DATA"][::core::mem::align_of::<_NV_ENC_H264_MV_DATA>() - 4usize];
    ["Offset of field: _NV_ENC_H264_MV_DATA::mv"]
        [::core::mem::offset_of!(_NV_ENC_H264_MV_DATA, mv) - 0usize];
    ["Offset of field: _NV_ENC_H264_MV_DATA::mbType"]
        [::core::mem::offset_of!(_NV_ENC_H264_MV_DATA, mbType) - 16usize];
    ["Offset of field: _NV_ENC_H264_MV_DATA::partitionType"]
        [::core::mem::offset_of!(_NV_ENC_H264_MV_DATA, partitionType) - 17usize];
    ["Offset of field: _NV_ENC_H264_MV_DATA::reserved"]
        [::core::mem::offset_of!(_NV_ENC_H264_MV_DATA, reserved) - 18usize];
    ["Offset of field: _NV_ENC_H264_MV_DATA::mbCost"]
        [::core::mem::offset_of!(_NV_ENC_H264_MV_DATA, mbCost) - 20usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_HEVC_MV_DATA"][::core::mem::size_of::<_NV_ENC_HEVC_MV_DATA>() - 20usize];
    ["Alignment of _NV_ENC_HEVC_MV_DATA"][::core::mem::align_of::<_NV_ENC_HEVC_MV_DATA>() - 2usize];
    ["Offset of field: _NV_ENC_HEVC_MV_DATA::mv"]
        [::core::mem::offset_of!(_NV_ENC_HEVC_MV_DATA, mv) - 0usize];
    ["Offset of field: _NV_ENC_HEVC_MV_DATA::cuType"]
        [::core::mem::offset_of!(_NV_ENC_HEVC_MV_DATA, cuType) - 16usize];
    ["Offset of field: _NV_ENC_HEVC_MV_DATA::cuSize"]
        [::core::mem::offset_of!(_NV_ENC_HEVC_MV_DATA, cuSize) - 17usize];
    ["Offset of field: _NV_ENC_HEVC_MV_DATA::partitionMode"]
        [::core::mem::offset_of!(_NV_ENC_HEVC_MV_DATA, partitionMode) - 18usize];
    ["Offset of field: _NV_ENC_HEVC_MV_DATA::lastCUInCTB"]
        [::core::mem::offset_of!(_NV_ENC_HEVC_MV_DATA, lastCUInCTB) - 19usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_CREATE_MV_BUFFER"]
        [::core::mem::size_of::<_NV_ENC_CREATE_MV_BUFFER>() - 1536usize];
    ["Alignment of _NV_ENC_CREATE_MV_BUFFER"]
        [::core::mem::align_of::<_NV_ENC_CREATE_MV_BUFFER>() - 8usize];
    ["Offset of field: _NV_ENC_CREATE_MV_BUFFER::version"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_MV_BUFFER, version) - 0usize];
    ["Offset of field: _NV_ENC_CREATE_MV_BUFFER::reserved"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_MV_BUFFER, reserved) - 4usize];
    ["Offset of field: _NV_ENC_CREATE_MV_BUFFER::mvBuffer"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_MV_BUFFER, mvBuffer) - 8usize];
    ["Offset of field: _NV_ENC_CREATE_MV_BUFFER::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_MV_BUFFER, reserved1) - 16usize];
    ["Offset of field: _NV_ENC_CREATE_MV_BUFFER::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_CREATE_MV_BUFFER, reserved2) - 1032usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_QP"][::core::mem::size_of::<_NV_ENC_QP>() - 12usize];
    ["Alignment of _NV_ENC_QP"][::core::mem::align_of::<_NV_ENC_QP>() - 4usize];
    ["Offset of field: _NV_ENC_QP::qpInterP"]
        [::core::mem::offset_of!(_NV_ENC_QP, qpInterP) - 0usize];
    ["Offset of field: _NV_ENC_QP::qpInterB"]
        [::core::mem::offset_of!(_NV_ENC_QP, qpInterB) - 4usize];
    ["Offset of field: _NV_ENC_QP::qpIntra"][::core::mem::offset_of!(_NV_ENC_QP, qpIntra) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_RC_PARAMS"][::core::mem::size_of::<_NV_ENC_RC_PARAMS>() - 128usize];
    ["Alignment of _NV_ENC_RC_PARAMS"][::core::mem::align_of::<_NV_ENC_RC_PARAMS>() - 4usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::version"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, version) - 0usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::rateControlMode"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, rateControlMode) - 4usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::constQP"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, constQP) - 8usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::averageBitRate"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, averageBitRate) - 20usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::maxBitRate"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, maxBitRate) - 24usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::vbvBufferSize"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, vbvBufferSize) - 28usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::vbvInitialDelay"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, vbvInitialDelay) - 32usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::minQP"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, minQP) - 40usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::maxQP"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, maxQP) - 52usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::initialRCQP"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, initialRCQP) - 64usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::temporallayerIdxMask"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, temporallayerIdxMask) - 76usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::temporalLayerQP"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, temporalLayerQP) - 80usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::targetQuality"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, targetQuality) - 88usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::targetQualityLSB"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, targetQualityLSB) - 89usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::lookaheadDepth"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, lookaheadDepth) - 90usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::lowDelayKeyFrameScale"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, lowDelayKeyFrameScale) - 92usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::yDcQPIndexOffset"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, yDcQPIndexOffset) - 93usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::uDcQPIndexOffset"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, uDcQPIndexOffset) - 94usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::vDcQPIndexOffset"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, vDcQPIndexOffset) - 95usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::qpMapMode"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, qpMapMode) - 96usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::multiPass"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, multiPass) - 100usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::alphaLayerBitrateRatio"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, alphaLayerBitrateRatio) - 104usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::cbQPIndexOffset"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, cbQPIndexOffset) - 108usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::crQPIndexOffset"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, crQPIndexOffset) - 109usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, reserved2) - 110usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::lookaheadLevel"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, lookaheadLevel) - 112usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::viewBitrateRatios"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, viewBitrateRatios) - 116usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::reserved3"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, reserved3) - 123usize];
    ["Offset of field: _NV_ENC_RC_PARAMS::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_RC_PARAMS, reserved1) - 124usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_CLOCK_TIMESTAMP_SET"]
        [::core::mem::size_of::<_NV_ENC_CLOCK_TIMESTAMP_SET>() - 8usize];
    ["Alignment of _NV_ENC_CLOCK_TIMESTAMP_SET"]
        [::core::mem::align_of::<_NV_ENC_CLOCK_TIMESTAMP_SET>() - 4usize];
    ["Offset of field: _NV_ENC_CLOCK_TIMESTAMP_SET::timeOffset"]
        [::core::mem::offset_of!(_NV_ENC_CLOCK_TIMESTAMP_SET, timeOffset) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_TIME_CODE"][::core::mem::size_of::<_NV_ENC_TIME_CODE>() - 32usize];
    ["Alignment of _NV_ENC_TIME_CODE"][::core::mem::align_of::<_NV_ENC_TIME_CODE>() - 4usize];
    ["Offset of field: _NV_ENC_TIME_CODE::displayPicStruct"]
        [::core::mem::offset_of!(_NV_ENC_TIME_CODE, displayPicStruct) - 0usize];
    ["Offset of field: _NV_ENC_TIME_CODE::clockTimestamp"]
        [::core::mem::offset_of!(_NV_ENC_TIME_CODE, clockTimestamp) - 4usize];
    ["Offset of field: _NV_ENC_TIME_CODE::skipClockTimestampInsertion"]
        [::core::mem::offset_of!(_NV_ENC_TIME_CODE, skipClockTimestampInsertion) - 28usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HEVC_3D_REFERENCE_DISPLAY_INFO"]
        [::core::mem::size_of::<_HEVC_3D_REFERENCE_DISPLAY_INFO>() - 960usize];
    ["Alignment of _HEVC_3D_REFERENCE_DISPLAY_INFO"]
        [::core::mem::align_of::<_HEVC_3D_REFERENCE_DISPLAY_INFO>() - 4usize];
    ["Offset of field: _HEVC_3D_REFERENCE_DISPLAY_INFO::precRefDisplayWidth"]
        [::core::mem::offset_of!(_HEVC_3D_REFERENCE_DISPLAY_INFO, precRefDisplayWidth) - 4usize];
    ["Offset of field: _HEVC_3D_REFERENCE_DISPLAY_INFO::precRefViewingDist"]
        [::core::mem::offset_of!(_HEVC_3D_REFERENCE_DISPLAY_INFO, precRefViewingDist) - 8usize];
    ["Offset of field: _HEVC_3D_REFERENCE_DISPLAY_INFO::numRefDisplaysMinus1"]
        [::core::mem::offset_of!(_HEVC_3D_REFERENCE_DISPLAY_INFO, numRefDisplaysMinus1) - 12usize];
    ["Offset of field: _HEVC_3D_REFERENCE_DISPLAY_INFO::leftViewId"]
        [::core::mem::offset_of!(_HEVC_3D_REFERENCE_DISPLAY_INFO, leftViewId) - 16usize];
    ["Offset of field: _HEVC_3D_REFERENCE_DISPLAY_INFO::rightViewId"]
        [::core::mem::offset_of!(_HEVC_3D_REFERENCE_DISPLAY_INFO, rightViewId) - 144usize];
    ["Offset of field: _HEVC_3D_REFERENCE_DISPLAY_INFO::exponentRefDisplayWidth"][::core::mem::offset_of!(
        _HEVC_3D_REFERENCE_DISPLAY_INFO,
        exponentRefDisplayWidth
    ) - 272usize];
    ["Offset of field: _HEVC_3D_REFERENCE_DISPLAY_INFO::mantissaRefDisplayWidth"][::core::mem::offset_of!(
        _HEVC_3D_REFERENCE_DISPLAY_INFO,
        mantissaRefDisplayWidth
    ) - 400usize];
    ["Offset of field: _HEVC_3D_REFERENCE_DISPLAY_INFO::exponentRefViewingDistance"][::core::mem::offset_of!(
        _HEVC_3D_REFERENCE_DISPLAY_INFO,
        exponentRefViewingDistance
    ) - 528usize];
    ["Offset of field: _HEVC_3D_REFERENCE_DISPLAY_INFO::mantissaRefViewingDistance"][::core::mem::offset_of!(
        _HEVC_3D_REFERENCE_DISPLAY_INFO,
        mantissaRefViewingDistance
    ) - 656usize];
    ["Offset of field: _HEVC_3D_REFERENCE_DISPLAY_INFO::numSampleShiftPlus512"][::core::mem::offset_of!(
        _HEVC_3D_REFERENCE_DISPLAY_INFO,
        numSampleShiftPlus512
    ) - 784usize];
    ["Offset of field: _HEVC_3D_REFERENCE_DISPLAY_INFO::additionalShiftPresentFlag"][::core::mem::offset_of!(
        _HEVC_3D_REFERENCE_DISPLAY_INFO,
        additionalShiftPresentFlag
    ) - 912usize];
    ["Offset of field: _HEVC_3D_REFERENCE_DISPLAY_INFO::reserved2"]
        [::core::mem::offset_of!(_HEVC_3D_REFERENCE_DISPLAY_INFO, reserved2) - 944usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _CHROMA_POINTS"][::core::mem::size_of::<_CHROMA_POINTS>() - 4usize];
    ["Alignment of _CHROMA_POINTS"][::core::mem::align_of::<_CHROMA_POINTS>() - 2usize];
    ["Offset of field: _CHROMA_POINTS::x"][::core::mem::offset_of!(_CHROMA_POINTS, x) - 0usize];
    ["Offset of field: _CHROMA_POINTS::y"][::core::mem::offset_of!(_CHROMA_POINTS, y) - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _MASTERING_DISPLAY_INFO"]
        [::core::mem::size_of::<_MASTERING_DISPLAY_INFO>() - 24usize];
    ["Alignment of _MASTERING_DISPLAY_INFO"]
        [::core::mem::align_of::<_MASTERING_DISPLAY_INFO>() - 4usize];
    ["Offset of field: _MASTERING_DISPLAY_INFO::g"]
        [::core::mem::offset_of!(_MASTERING_DISPLAY_INFO, g) - 0usize];
    ["Offset of field: _MASTERING_DISPLAY_INFO::b"]
        [::core::mem::offset_of!(_MASTERING_DISPLAY_INFO, b) - 4usize];
    ["Offset of field: _MASTERING_DISPLAY_INFO::r"]
        [::core::mem::offset_of!(_MASTERING_DISPLAY_INFO, r) - 8usize];
    ["Offset of field: _MASTERING_DISPLAY_INFO::whitePoint"]
        [::core::mem::offset_of!(_MASTERING_DISPLAY_INFO, whitePoint) - 12usize];
    ["Offset of field: _MASTERING_DISPLAY_INFO::maxLuma"]
        [::core::mem::offset_of!(_MASTERING_DISPLAY_INFO, maxLuma) - 16usize];
    ["Offset of field: _MASTERING_DISPLAY_INFO::minLuma"]
        [::core::mem::offset_of!(_MASTERING_DISPLAY_INFO, minLuma) - 20usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _CONTENT_LIGHT_LEVEL"][::core::mem::size_of::<_CONTENT_LIGHT_LEVEL>() - 4usize];
    ["Alignment of _CONTENT_LIGHT_LEVEL"][::core::mem::align_of::<_CONTENT_LIGHT_LEVEL>() - 2usize];
    ["Offset of field: _CONTENT_LIGHT_LEVEL::maxContentLightLevel"]
        [::core::mem::offset_of!(_CONTENT_LIGHT_LEVEL, maxContentLightLevel) - 0usize];
    ["Offset of field: _CONTENT_LIGHT_LEVEL::maxPicAverageLightLevel"]
        [::core::mem::offset_of!(_CONTENT_LIGHT_LEVEL, maxPicAverageLightLevel) - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_CONFIG_H264_VUI_PARAMETERS"]
        [::core::mem::size_of::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>() - 112usize];
    ["Alignment of _NV_ENC_CONFIG_H264_VUI_PARAMETERS"]
        [::core::mem::align_of::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>() - 4usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::overscanInfoPresentFlag"][::core::mem::offset_of!(
        _NV_ENC_CONFIG_H264_VUI_PARAMETERS,
        overscanInfoPresentFlag
    ) - 0usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::overscanInfo"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS, overscanInfo) - 4usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::videoSignalTypePresentFlag"][::core::mem::offset_of!(
        _NV_ENC_CONFIG_H264_VUI_PARAMETERS,
        videoSignalTypePresentFlag
    ) - 8usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::videoFormat"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS, videoFormat) - 12usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::videoFullRangeFlag"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS, videoFullRangeFlag) - 16usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::colourDescriptionPresentFlag"][::core::mem::offset_of!(
        _NV_ENC_CONFIG_H264_VUI_PARAMETERS,
        colourDescriptionPresentFlag
    )
        - 20usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::colourPrimaries"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS, colourPrimaries) - 24usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::transferCharacteristics"][::core::mem::offset_of!(
        _NV_ENC_CONFIG_H264_VUI_PARAMETERS,
        transferCharacteristics
    ) - 28usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::colourMatrix"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS, colourMatrix) - 32usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::chromaSampleLocationFlag"][::core::mem::offset_of!(
        _NV_ENC_CONFIG_H264_VUI_PARAMETERS,
        chromaSampleLocationFlag
    ) - 36usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::chromaSampleLocationTop"][::core::mem::offset_of!(
        _NV_ENC_CONFIG_H264_VUI_PARAMETERS,
        chromaSampleLocationTop
    ) - 40usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::chromaSampleLocationBot"][::core::mem::offset_of!(
        _NV_ENC_CONFIG_H264_VUI_PARAMETERS,
        chromaSampleLocationBot
    ) - 44usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::bitstreamRestrictionFlag"][::core::mem::offset_of!(
        _NV_ENC_CONFIG_H264_VUI_PARAMETERS,
        bitstreamRestrictionFlag
    ) - 48usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::timingInfoPresentFlag"][::core::mem::offset_of!(
        _NV_ENC_CONFIG_H264_VUI_PARAMETERS,
        timingInfoPresentFlag
    ) - 52usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::numUnitInTicks"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS, numUnitInTicks) - 56usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::timeScale"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS, timeScale) - 60usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_VUI_PARAMETERS::reserved"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS, reserved) - 64usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE"]
        [::core::mem::size_of::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>() - 16usize];
    ["Alignment of _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE"]
        [::core::mem::align_of::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>() - 4usize];
    ["Offset of field: _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::reserved1"]
        [::core::mem::offset_of!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE, reserved1) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NVENC_EXTERNAL_ME_HINT"][::core::mem::size_of::<_NVENC_EXTERNAL_ME_HINT>() - 4usize];
    ["Alignment of _NVENC_EXTERNAL_ME_HINT"]
        [::core::mem::align_of::<_NVENC_EXTERNAL_ME_HINT>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NVENC_EXTERNAL_ME_SB_HINT"]
        [::core::mem::size_of::<_NVENC_EXTERNAL_ME_SB_HINT>() - 6usize];
    ["Alignment of _NVENC_EXTERNAL_ME_SB_HINT"]
        [::core::mem::align_of::<_NVENC_EXTERNAL_ME_SB_HINT>() - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_CONFIG_H264"][::core::mem::size_of::<_NV_ENC_CONFIG_H264>() - 1792usize];
    ["Alignment of _NV_ENC_CONFIG_H264"][::core::mem::align_of::<_NV_ENC_CONFIG_H264>() - 8usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::level"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, level) - 4usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::idrPeriod"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, idrPeriod) - 8usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::separateColourPlaneFlag"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, separateColourPlaneFlag) - 12usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::disableDeblockingFilterIDC"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, disableDeblockingFilterIDC) - 16usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::numTemporalLayers"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, numTemporalLayers) - 20usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::spsId"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, spsId) - 24usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::ppsId"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, ppsId) - 28usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::adaptiveTransformMode"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, adaptiveTransformMode) - 32usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::fmoMode"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, fmoMode) - 36usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::bdirectMode"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, bdirectMode) - 40usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::entropyCodingMode"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, entropyCodingMode) - 44usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::stereoMode"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, stereoMode) - 48usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::intraRefreshPeriod"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, intraRefreshPeriod) - 52usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::intraRefreshCnt"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, intraRefreshCnt) - 56usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::maxNumRefFrames"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, maxNumRefFrames) - 60usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::sliceMode"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, sliceMode) - 64usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::sliceModeData"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, sliceModeData) - 68usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::h264VUIParameters"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, h264VUIParameters) - 72usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::ltrNumFrames"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, ltrNumFrames) - 184usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::ltrTrustMode"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, ltrTrustMode) - 188usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::chromaFormatIDC"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, chromaFormatIDC) - 192usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::maxTemporalLayers"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, maxTemporalLayers) - 196usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::useBFramesAsRef"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, useBFramesAsRef) - 200usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::numRefL0"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, numRefL0) - 204usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::numRefL1"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, numRefL1) - 208usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::outputBitDepth"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, outputBitDepth) - 212usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::inputBitDepth"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, inputBitDepth) - 216usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::tfLevel"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, tfLevel) - 220usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, reserved1) - 224usize];
    ["Offset of field: _NV_ENC_CONFIG_H264::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264, reserved2) - 1280usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_CONFIG_HEVC"][::core::mem::size_of::<_NV_ENC_CONFIG_HEVC>() - 1560usize];
    ["Alignment of _NV_ENC_CONFIG_HEVC"][::core::mem::align_of::<_NV_ENC_CONFIG_HEVC>() - 8usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::level"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, level) - 0usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::tier"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, tier) - 4usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::minCUSize"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, minCUSize) - 8usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::maxCUSize"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, maxCUSize) - 12usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::idrPeriod"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, idrPeriod) - 20usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::intraRefreshPeriod"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, intraRefreshPeriod) - 24usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::intraRefreshCnt"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, intraRefreshCnt) - 28usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::maxNumRefFramesInDPB"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, maxNumRefFramesInDPB) - 32usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::ltrNumFrames"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, ltrNumFrames) - 36usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::vpsId"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, vpsId) - 40usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::spsId"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, spsId) - 44usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::ppsId"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, ppsId) - 48usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::sliceMode"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, sliceMode) - 52usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::sliceModeData"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, sliceModeData) - 56usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::maxTemporalLayersMinus1"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, maxTemporalLayersMinus1) - 60usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::hevcVUIParameters"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, hevcVUIParameters) - 64usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::ltrTrustMode"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, ltrTrustMode) - 176usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::useBFramesAsRef"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, useBFramesAsRef) - 180usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::numRefL0"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, numRefL0) - 184usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::numRefL1"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, numRefL1) - 188usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::tfLevel"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, tfLevel) - 192usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::disableDeblockingFilterIDC"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, disableDeblockingFilterIDC) - 196usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::outputBitDepth"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, outputBitDepth) - 200usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::inputBitDepth"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, inputBitDepth) - 204usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::numTemporalLayers"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, numTemporalLayers) - 208usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::numViews"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, numViews) - 212usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, reserved1) - 216usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC, reserved2) - 1048usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_FILM_GRAIN_PARAMS_AV1"]
        [::core::mem::size_of::<_NV_ENC_FILM_GRAIN_PARAMS_AV1>() - 156usize];
    ["Alignment of _NV_ENC_FILM_GRAIN_PARAMS_AV1"]
        [::core::mem::align_of::<_NV_ENC_FILM_GRAIN_PARAMS_AV1>() - 4usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::pointYValue"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, pointYValue) - 4usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::pointYScaling"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, pointYScaling) - 18usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::pointCbValue"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, pointCbValue) - 32usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::pointCbScaling"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, pointCbScaling) - 42usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::pointCrValue"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, pointCrValue) - 52usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::pointCrScaling"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, pointCrScaling) - 62usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::arCoeffsYPlus128"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, arCoeffsYPlus128) - 72usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::arCoeffsCbPlus128"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, arCoeffsCbPlus128) - 96usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::arCoeffsCrPlus128"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, arCoeffsCrPlus128) - 121usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, reserved2) - 146usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::cbMult"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, cbMult) - 148usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::cbLumaMult"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, cbLumaMult) - 149usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::cbOffset"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, cbOffset) - 150usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::crMult"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, crMult) - 152usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::crLumaMult"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, crLumaMult) - 153usize];
    ["Offset of field: _NV_ENC_FILM_GRAIN_PARAMS_AV1::crOffset"]
        [::core::mem::offset_of!(_NV_ENC_FILM_GRAIN_PARAMS_AV1, crOffset) - 154usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_CONFIG_AV1"][::core::mem::size_of::<_NV_ENC_CONFIG_AV1>() - 1552usize];
    ["Alignment of _NV_ENC_CONFIG_AV1"][::core::mem::align_of::<_NV_ENC_CONFIG_AV1>() - 8usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::level"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, level) - 0usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::tier"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, tier) - 4usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::minPartSize"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, minPartSize) - 8usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::maxPartSize"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, maxPartSize) - 12usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::idrPeriod"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, idrPeriod) - 20usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::intraRefreshPeriod"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, intraRefreshPeriod) - 24usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::intraRefreshCnt"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, intraRefreshCnt) - 28usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::maxNumRefFramesInDPB"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, maxNumRefFramesInDPB) - 32usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::numTileColumns"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, numTileColumns) - 36usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::numTileRows"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, numTileRows) - 40usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, reserved2) - 44usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::tileWidths"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, tileWidths) - 48usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::tileHeights"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, tileHeights) - 56usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::maxTemporalLayersMinus1"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, maxTemporalLayersMinus1) - 64usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::colorPrimaries"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, colorPrimaries) - 68usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::transferCharacteristics"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, transferCharacteristics) - 72usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::matrixCoefficients"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, matrixCoefficients) - 76usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::colorRange"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, colorRange) - 80usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::chromaSamplePosition"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, chromaSamplePosition) - 84usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::useBFramesAsRef"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, useBFramesAsRef) - 88usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::filmGrainParams"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, filmGrainParams) - 96usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::numFwdRefs"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, numFwdRefs) - 104usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::numBwdRefs"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, numBwdRefs) - 108usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::outputBitDepth"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, outputBitDepth) - 112usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::inputBitDepth"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, inputBitDepth) - 116usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::ltrNumFrames"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, ltrNumFrames) - 120usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::numTemporalLayers"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, numTemporalLayers) - 124usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::tfLevel"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, tfLevel) - 128usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, reserved1) - 132usize];
    ["Offset of field: _NV_ENC_CONFIG_AV1::reserved3"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_AV1, reserved3) - 1056usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_CONFIG_H264_MEONLY"]
        [::core::mem::size_of::<_NV_ENC_CONFIG_H264_MEONLY>() - 1536usize];
    ["Alignment of _NV_ENC_CONFIG_H264_MEONLY"]
        [::core::mem::align_of::<_NV_ENC_CONFIG_H264_MEONLY>() - 8usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_MEONLY::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264_MEONLY, reserved1) - 4usize];
    ["Offset of field: _NV_ENC_CONFIG_H264_MEONLY::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_H264_MEONLY, reserved2) - 1024usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_CONFIG_HEVC_MEONLY"]
        [::core::mem::size_of::<_NV_ENC_CONFIG_HEVC_MEONLY>() - 1536usize];
    ["Alignment of _NV_ENC_CONFIG_HEVC_MEONLY"]
        [::core::mem::align_of::<_NV_ENC_CONFIG_HEVC_MEONLY>() - 8usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC_MEONLY::reserved"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC_MEONLY, reserved) - 0usize];
    ["Offset of field: _NV_ENC_CONFIG_HEVC_MEONLY::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG_HEVC_MEONLY, reserved1) - 1024usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_CODEC_CONFIG"][::core::mem::size_of::<_NV_ENC_CODEC_CONFIG>() - 1792usize];
    ["Alignment of _NV_ENC_CODEC_CONFIG"][::core::mem::align_of::<_NV_ENC_CODEC_CONFIG>() - 8usize];
    ["Offset of field: _NV_ENC_CODEC_CONFIG::h264Config"]
        [::core::mem::offset_of!(_NV_ENC_CODEC_CONFIG, h264Config) - 0usize];
    ["Offset of field: _NV_ENC_CODEC_CONFIG::hevcConfig"]
        [::core::mem::offset_of!(_NV_ENC_CODEC_CONFIG, hevcConfig) - 0usize];
    ["Offset of field: _NV_ENC_CODEC_CONFIG::av1Config"]
        [::core::mem::offset_of!(_NV_ENC_CODEC_CONFIG, av1Config) - 0usize];
    ["Offset of field: _NV_ENC_CODEC_CONFIG::h264MeOnlyConfig"]
        [::core::mem::offset_of!(_NV_ENC_CODEC_CONFIG, h264MeOnlyConfig) - 0usize];
    ["Offset of field: _NV_ENC_CODEC_CONFIG::hevcMeOnlyConfig"]
        [::core::mem::offset_of!(_NV_ENC_CODEC_CONFIG, hevcMeOnlyConfig) - 0usize];
    ["Offset of field: _NV_ENC_CODEC_CONFIG::reserved"]
        [::core::mem::offset_of!(_NV_ENC_CODEC_CONFIG, reserved) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_CONFIG"][::core::mem::size_of::<_NV_ENC_CONFIG>() - 3584usize];
    ["Alignment of _NV_ENC_CONFIG"][::core::mem::align_of::<_NV_ENC_CONFIG>() - 8usize];
    ["Offset of field: _NV_ENC_CONFIG::version"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG, version) - 0usize];
    ["Offset of field: _NV_ENC_CONFIG::profileGUID"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG, profileGUID) - 4usize];
    ["Offset of field: _NV_ENC_CONFIG::gopLength"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG, gopLength) - 20usize];
    ["Offset of field: _NV_ENC_CONFIG::frameIntervalP"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG, frameIntervalP) - 24usize];
    ["Offset of field: _NV_ENC_CONFIG::monoChromeEncoding"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG, monoChromeEncoding) - 28usize];
    ["Offset of field: _NV_ENC_CONFIG::frameFieldMode"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG, frameFieldMode) - 32usize];
    ["Offset of field: _NV_ENC_CONFIG::mvPrecision"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG, mvPrecision) - 36usize];
    ["Offset of field: _NV_ENC_CONFIG::rcParams"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG, rcParams) - 40usize];
    ["Offset of field: _NV_ENC_CONFIG::encodeCodecConfig"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG, encodeCodecConfig) - 168usize];
    ["Offset of field: _NV_ENC_CONFIG::reserved"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG, reserved) - 1960usize];
    ["Offset of field: _NV_ENC_CONFIG::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_CONFIG, reserved2) - 3072usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_INITIALIZE_PARAMS"]
        [::core::mem::size_of::<_NV_ENC_INITIALIZE_PARAMS>() - 1800usize];
    ["Alignment of _NV_ENC_INITIALIZE_PARAMS"]
        [::core::mem::align_of::<_NV_ENC_INITIALIZE_PARAMS>() - 8usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::version"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, version) - 0usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::encodeGUID"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, encodeGUID) - 4usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::presetGUID"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, presetGUID) - 20usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::encodeWidth"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, encodeWidth) - 36usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::encodeHeight"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, encodeHeight) - 40usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::darWidth"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, darWidth) - 44usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::darHeight"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, darHeight) - 48usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::frameRateNum"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, frameRateNum) - 52usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::frameRateDen"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, frameRateDen) - 56usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, enableEncodeAsync) - 60usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::enablePTD"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, enablePTD) - 64usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::privDataSize"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, privDataSize) - 72usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::reserved"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, reserved) - 76usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::privData"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, privData) - 80usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::encodeConfig"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, encodeConfig) - 88usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::maxEncodeWidth"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, maxEncodeWidth) - 96usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::maxEncodeHeight"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, maxEncodeHeight) - 100usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, maxMEHintCountsPerBlock) - 104usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::tuningInfo"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, tuningInfo) - 136usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::bufferFormat"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, bufferFormat) - 140usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::numStateBuffers"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, numStateBuffers) - 144usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::outputStatsLevel"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, outputStatsLevel) - 148usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, reserved1) - 152usize];
    ["Offset of field: _NV_ENC_INITIALIZE_PARAMS::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_INITIALIZE_PARAMS, reserved2) - 1288usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_RECONFIGURE_PARAMS"]
        [::core::mem::size_of::<_NV_ENC_RECONFIGURE_PARAMS>() - 1816usize];
    ["Alignment of _NV_ENC_RECONFIGURE_PARAMS"]
        [::core::mem::align_of::<_NV_ENC_RECONFIGURE_PARAMS>() - 8usize];
    ["Offset of field: _NV_ENC_RECONFIGURE_PARAMS::version"]
        [::core::mem::offset_of!(_NV_ENC_RECONFIGURE_PARAMS, version) - 0usize];
    ["Offset of field: _NV_ENC_RECONFIGURE_PARAMS::reserved"]
        [::core::mem::offset_of!(_NV_ENC_RECONFIGURE_PARAMS, reserved) - 4usize];
    ["Offset of field: _NV_ENC_RECONFIGURE_PARAMS::reInitEncodeParams"]
        [::core::mem::offset_of!(_NV_ENC_RECONFIGURE_PARAMS, reInitEncodeParams) - 8usize];
    ["Offset of field: _NV_ENC_RECONFIGURE_PARAMS::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_RECONFIGURE_PARAMS, reserved2) - 1812usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_PRESET_CONFIG"][::core::mem::size_of::<_NV_ENC_PRESET_CONFIG>() - 5128usize];
    ["Alignment of _NV_ENC_PRESET_CONFIG"]
        [::core::mem::align_of::<_NV_ENC_PRESET_CONFIG>() - 8usize];
    ["Offset of field: _NV_ENC_PRESET_CONFIG::version"]
        [::core::mem::offset_of!(_NV_ENC_PRESET_CONFIG, version) - 0usize];
    ["Offset of field: _NV_ENC_PRESET_CONFIG::reserved"]
        [::core::mem::offset_of!(_NV_ENC_PRESET_CONFIG, reserved) - 4usize];
    ["Offset of field: _NV_ENC_PRESET_CONFIG::presetCfg"]
        [::core::mem::offset_of!(_NV_ENC_PRESET_CONFIG, presetCfg) - 8usize];
    ["Offset of field: _NV_ENC_PRESET_CONFIG::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_PRESET_CONFIG, reserved1) - 3592usize];
    ["Offset of field: _NV_ENC_PRESET_CONFIG::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_PRESET_CONFIG, reserved2) - 4616usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_PIC_PARAMS_MVC"][::core::mem::size_of::<_NV_ENC_PIC_PARAMS_MVC>() - 128usize];
    ["Alignment of _NV_ENC_PIC_PARAMS_MVC"]
        [::core::mem::align_of::<_NV_ENC_PIC_PARAMS_MVC>() - 8usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_MVC::version"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_MVC, version) - 0usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_MVC::viewID"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_MVC, viewID) - 4usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_MVC::temporalID"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_MVC, temporalID) - 8usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_MVC::priorityID"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_MVC, priorityID) - 12usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_MVC::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_MVC, reserved1) - 16usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_MVC::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_MVC, reserved2) - 64usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_PIC_PARAMS_H264_EXT"]
        [::core::mem::size_of::<_NV_ENC_PIC_PARAMS_H264_EXT>() - 128usize];
    ["Alignment of _NV_ENC_PIC_PARAMS_H264_EXT"]
        [::core::mem::align_of::<_NV_ENC_PIC_PARAMS_H264_EXT>() - 8usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264_EXT::mvcPicParams"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264_EXT, mvcPicParams) - 0usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264_EXT::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264_EXT, reserved1) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_SEI_PAYLOAD"][::core::mem::size_of::<_NV_ENC_SEI_PAYLOAD>() - 16usize];
    ["Alignment of _NV_ENC_SEI_PAYLOAD"][::core::mem::align_of::<_NV_ENC_SEI_PAYLOAD>() - 8usize];
    ["Offset of field: _NV_ENC_SEI_PAYLOAD::payloadSize"]
        [::core::mem::offset_of!(_NV_ENC_SEI_PAYLOAD, payloadSize) - 0usize];
    ["Offset of field: _NV_ENC_SEI_PAYLOAD::payloadType"]
        [::core::mem::offset_of!(_NV_ENC_SEI_PAYLOAD, payloadType) - 4usize];
    ["Offset of field: _NV_ENC_SEI_PAYLOAD::payload"]
        [::core::mem::offset_of!(_NV_ENC_SEI_PAYLOAD, payload) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_PIC_PARAMS_H264"]
        [::core::mem::size_of::<_NV_ENC_PIC_PARAMS_H264>() - 1536usize];
    ["Alignment of _NV_ENC_PIC_PARAMS_H264"]
        [::core::mem::align_of::<_NV_ENC_PIC_PARAMS_H264>() - 8usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::displayPOCSyntax"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, displayPOCSyntax) - 0usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::reserved3"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, reserved3) - 4usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::refPicFlag"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, refPicFlag) - 8usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::colourPlaneId"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, colourPlaneId) - 12usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::forceIntraRefreshWithFrameCnt"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, forceIntraRefreshWithFrameCnt) - 16usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::sliceTypeData"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, sliceTypeData) - 24usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::sliceTypeArrayCnt"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, sliceTypeArrayCnt) - 32usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::seiPayloadArrayCnt"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, seiPayloadArrayCnt) - 36usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::seiPayloadArray"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, seiPayloadArray) - 40usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::sliceMode"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, sliceMode) - 48usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::sliceModeData"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, sliceModeData) - 52usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::ltrMarkFrameIdx"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, ltrMarkFrameIdx) - 56usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::ltrUseFrameBitmap"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, ltrUseFrameBitmap) - 60usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::ltrUsageMode"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, ltrUsageMode) - 64usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::forceIntraSliceCount"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, forceIntraSliceCount) - 68usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::forceIntraSliceIdx"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, forceIntraSliceIdx) - 72usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::h264ExtPicParams"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, h264ExtPicParams) - 80usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::timeCode"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, timeCode) - 208usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::reserved"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, reserved) - 240usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_H264::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_H264, reserved2) - 1048usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_PIC_PARAMS_HEVC"]
        [::core::mem::size_of::<_NV_ENC_PIC_PARAMS_HEVC>() - 1536usize];
    ["Alignment of _NV_ENC_PIC_PARAMS_HEVC"]
        [::core::mem::align_of::<_NV_ENC_PIC_PARAMS_HEVC>() - 8usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::displayPOCSyntax"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, displayPOCSyntax) - 0usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::refPicFlag"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, refPicFlag) - 4usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::temporalId"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, temporalId) - 8usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::forceIntraRefreshWithFrameCnt"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, forceIntraRefreshWithFrameCnt) - 12usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, reserved1) - 20usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::sliceTypeData"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, sliceTypeData) - 24usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::sliceTypeArrayCnt"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, sliceTypeArrayCnt) - 32usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::sliceMode"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, sliceMode) - 36usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::sliceModeData"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, sliceModeData) - 40usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::ltrMarkFrameIdx"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, ltrMarkFrameIdx) - 44usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::ltrUseFrameBitmap"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, ltrUseFrameBitmap) - 48usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::ltrUsageMode"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, ltrUsageMode) - 52usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::seiPayloadArrayCnt"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, seiPayloadArrayCnt) - 56usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::reserved"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, reserved) - 60usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::seiPayloadArray"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, seiPayloadArray) - 64usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::timeCode"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, timeCode) - 72usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::numTemporalLayers"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, numTemporalLayers) - 104usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::viewId"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, viewId) - 108usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::p3DReferenceDisplayInfo"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, p3DReferenceDisplayInfo) - 112usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::pMaxCll"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, pMaxCll) - 120usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::pMasteringDisplay"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, pMasteringDisplay) - 128usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, reserved2) - 136usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_HEVC::reserved3"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_HEVC, reserved3) - 1072usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_PIC_PARAMS_AV1"]
        [::core::mem::size_of::<_NV_ENC_PIC_PARAMS_AV1>() - 1544usize];
    ["Alignment of _NV_ENC_PIC_PARAMS_AV1"]
        [::core::mem::align_of::<_NV_ENC_PIC_PARAMS_AV1>() - 8usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::displayPOCSyntax"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, displayPOCSyntax) - 0usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::refPicFlag"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, refPicFlag) - 4usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::temporalId"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, temporalId) - 8usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::forceIntraRefreshWithFrameCnt"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, forceIntraRefreshWithFrameCnt) - 12usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::numTileColumns"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, numTileColumns) - 20usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::numTileRows"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, numTileRows) - 24usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::reserved"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, reserved) - 28usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::tileWidths"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, tileWidths) - 32usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::tileHeights"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, tileHeights) - 40usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::obuPayloadArrayCnt"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, obuPayloadArrayCnt) - 48usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, reserved1) - 52usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::obuPayloadArray"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, obuPayloadArray) - 56usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::filmGrainParams"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, filmGrainParams) - 64usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::ltrMarkFrameIdx"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, ltrMarkFrameIdx) - 72usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::ltrUseFrameBitmap"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, ltrUseFrameBitmap) - 76usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::numTemporalLayers"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, numTemporalLayers) - 80usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::reserved4"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, reserved4) - 84usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::pMaxCll"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, pMaxCll) - 88usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::pMasteringDisplay"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, pMasteringDisplay) - 96usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, reserved2) - 104usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS_AV1::reserved3"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS_AV1, reserved3) - 1072usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_CODEC_PIC_PARAMS"]
        [::core::mem::size_of::<_NV_ENC_CODEC_PIC_PARAMS>() - 1544usize];
    ["Alignment of _NV_ENC_CODEC_PIC_PARAMS"]
        [::core::mem::align_of::<_NV_ENC_CODEC_PIC_PARAMS>() - 8usize];
    ["Offset of field: _NV_ENC_CODEC_PIC_PARAMS::h264PicParams"]
        [::core::mem::offset_of!(_NV_ENC_CODEC_PIC_PARAMS, h264PicParams) - 0usize];
    ["Offset of field: _NV_ENC_CODEC_PIC_PARAMS::hevcPicParams"]
        [::core::mem::offset_of!(_NV_ENC_CODEC_PIC_PARAMS, hevcPicParams) - 0usize];
    ["Offset of field: _NV_ENC_CODEC_PIC_PARAMS::av1PicParams"]
        [::core::mem::offset_of!(_NV_ENC_CODEC_PIC_PARAMS, av1PicParams) - 0usize];
    ["Offset of field: _NV_ENC_CODEC_PIC_PARAMS::reserved"]
        [::core::mem::offset_of!(_NV_ENC_CODEC_PIC_PARAMS, reserved) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_PIC_PARAMS"][::core::mem::size_of::<_NV_ENC_PIC_PARAMS>() - 3360usize];
    ["Alignment of _NV_ENC_PIC_PARAMS"][::core::mem::align_of::<_NV_ENC_PIC_PARAMS>() - 8usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::version"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, version) - 0usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::inputWidth"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, inputWidth) - 4usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::inputHeight"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, inputHeight) - 8usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::inputPitch"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, inputPitch) - 12usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::encodePicFlags"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, encodePicFlags) - 16usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::frameIdx"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, frameIdx) - 20usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::inputTimeStamp"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, inputTimeStamp) - 24usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::inputDuration"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, inputDuration) - 32usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::inputBuffer"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, inputBuffer) - 40usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::outputBitstream"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, outputBitstream) - 48usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::completionEvent"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, completionEvent) - 56usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::bufferFmt"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, bufferFmt) - 64usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::pictureStruct"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, pictureStruct) - 68usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::pictureType"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, pictureType) - 72usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::codecPicParams"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, codecPicParams) - 80usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::meHintCountsPerBlock"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, meHintCountsPerBlock) - 1624usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::meExternalHints"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, meExternalHints) - 1656usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, reserved2) - 1664usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::reserved5"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, reserved5) - 1696usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::qpDeltaMap"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, qpDeltaMap) - 1712usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::qpDeltaMapSize"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, qpDeltaMapSize) - 1720usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::reservedBitFields"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, reservedBitFields) - 1724usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::meHintRefPicDist"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, meHintRefPicDist) - 1728usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::reserved4"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, reserved4) - 1732usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::alphaBuffer"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, alphaBuffer) - 1736usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::meExternalSbHints"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, meExternalSbHints) - 1744usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::meSbHintsCount"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, meSbHintsCount) - 1752usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::stateBufferIdx"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, stateBufferIdx) - 1756usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::outputReconBuffer"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, outputReconBuffer) - 1760usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::reserved3"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, reserved3) - 1768usize];
    ["Offset of field: _NV_ENC_PIC_PARAMS::reserved6"]
        [::core::mem::offset_of!(_NV_ENC_PIC_PARAMS, reserved6) - 2904usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_MEONLY_PARAMS"][::core::mem::size_of::<_NV_ENC_MEONLY_PARAMS>() - 1544usize];
    ["Alignment of _NV_ENC_MEONLY_PARAMS"]
        [::core::mem::align_of::<_NV_ENC_MEONLY_PARAMS>() - 8usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::version"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, version) - 0usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::inputWidth"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, inputWidth) - 4usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::inputHeight"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, inputHeight) - 8usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::reserved"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, reserved) - 12usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::inputBuffer"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, inputBuffer) - 16usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::referenceFrame"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, referenceFrame) - 24usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::mvBuffer"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, mvBuffer) - 32usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, reserved2) - 40usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::bufferFmt"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, bufferFmt) - 44usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::completionEvent"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, completionEvent) - 48usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::viewID"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, viewID) - 56usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::meHintCountsPerBlock"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, meHintCountsPerBlock) - 60usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::meExternalHints"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, meExternalHints) - 96usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, reserved1) - 104usize];
    ["Offset of field: _NV_ENC_MEONLY_PARAMS::reserved3"]
        [::core::mem::offset_of!(_NV_ENC_MEONLY_PARAMS, reserved3) - 1072usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_LOCK_BITSTREAM"]
        [::core::mem::size_of::<_NV_ENC_LOCK_BITSTREAM>() - 1544usize];
    ["Alignment of _NV_ENC_LOCK_BITSTREAM"]
        [::core::mem::align_of::<_NV_ENC_LOCK_BITSTREAM>() - 8usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::version"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, version) - 0usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::outputBitstream"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, outputBitstream) - 8usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::sliceOffsets"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, sliceOffsets) - 16usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::frameIdx"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, frameIdx) - 24usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::hwEncodeStatus"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, hwEncodeStatus) - 28usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::numSlices"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, numSlices) - 32usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::bitstreamSizeInBytes"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, bitstreamSizeInBytes) - 36usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::outputTimeStamp"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, outputTimeStamp) - 40usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::outputDuration"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, outputDuration) - 48usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::bitstreamBufferPtr"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, bitstreamBufferPtr) - 56usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::pictureType"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, pictureType) - 64usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::pictureStruct"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, pictureStruct) - 68usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::frameAvgQP"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, frameAvgQP) - 72usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::frameSatd"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, frameSatd) - 76usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::ltrFrameIdx"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, ltrFrameIdx) - 80usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::ltrFrameBitmap"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, ltrFrameBitmap) - 84usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::temporalId"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, temporalId) - 88usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::intraMBCount"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, intraMBCount) - 92usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::interMBCount"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, interMBCount) - 96usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::averageMVX"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, averageMVX) - 100usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::averageMVY"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, averageMVY) - 104usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::alphaLayerSizeInBytes"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, alphaLayerSizeInBytes) - 108usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::outputStatsPtrSize"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, outputStatsPtrSize) - 112usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::reserved"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, reserved) - 116usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::outputStatsPtr"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, outputStatsPtr) - 120usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::frameIdxDisplay"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, frameIdxDisplay) - 128usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, reserved1) - 132usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, reserved2) - 1008usize];
    ["Offset of field: _NV_ENC_LOCK_BITSTREAM::reservedInternal"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_BITSTREAM, reservedInternal) - 1512usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_LOCK_INPUT_BUFFER"]
        [::core::mem::size_of::<_NV_ENC_LOCK_INPUT_BUFFER>() - 1544usize];
    ["Alignment of _NV_ENC_LOCK_INPUT_BUFFER"]
        [::core::mem::align_of::<_NV_ENC_LOCK_INPUT_BUFFER>() - 8usize];
    ["Offset of field: _NV_ENC_LOCK_INPUT_BUFFER::version"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_INPUT_BUFFER, version) - 0usize];
    ["Offset of field: _NV_ENC_LOCK_INPUT_BUFFER::inputBuffer"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_INPUT_BUFFER, inputBuffer) - 8usize];
    ["Offset of field: _NV_ENC_LOCK_INPUT_BUFFER::bufferDataPtr"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_INPUT_BUFFER, bufferDataPtr) - 16usize];
    ["Offset of field: _NV_ENC_LOCK_INPUT_BUFFER::pitch"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_INPUT_BUFFER, pitch) - 24usize];
    ["Offset of field: _NV_ENC_LOCK_INPUT_BUFFER::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_INPUT_BUFFER, reserved1) - 28usize];
    ["Offset of field: _NV_ENC_LOCK_INPUT_BUFFER::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_LOCK_INPUT_BUFFER, reserved2) - 1032usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_MAP_INPUT_RESOURCE"]
        [::core::mem::size_of::<_NV_ENC_MAP_INPUT_RESOURCE>() - 1544usize];
    ["Alignment of _NV_ENC_MAP_INPUT_RESOURCE"]
        [::core::mem::align_of::<_NV_ENC_MAP_INPUT_RESOURCE>() - 8usize];
    ["Offset of field: _NV_ENC_MAP_INPUT_RESOURCE::version"]
        [::core::mem::offset_of!(_NV_ENC_MAP_INPUT_RESOURCE, version) - 0usize];
    ["Offset of field: _NV_ENC_MAP_INPUT_RESOURCE::subResourceIndex"]
        [::core::mem::offset_of!(_NV_ENC_MAP_INPUT_RESOURCE, subResourceIndex) - 4usize];
    ["Offset of field: _NV_ENC_MAP_INPUT_RESOURCE::inputResource"]
        [::core::mem::offset_of!(_NV_ENC_MAP_INPUT_RESOURCE, inputResource) - 8usize];
    ["Offset of field: _NV_ENC_MAP_INPUT_RESOURCE::registeredResource"]
        [::core::mem::offset_of!(_NV_ENC_MAP_INPUT_RESOURCE, registeredResource) - 16usize];
    ["Offset of field: _NV_ENC_MAP_INPUT_RESOURCE::mappedResource"]
        [::core::mem::offset_of!(_NV_ENC_MAP_INPUT_RESOURCE, mappedResource) - 24usize];
    ["Offset of field: _NV_ENC_MAP_INPUT_RESOURCE::mappedBufferFmt"]
        [::core::mem::offset_of!(_NV_ENC_MAP_INPUT_RESOURCE, mappedBufferFmt) - 32usize];
    ["Offset of field: _NV_ENC_MAP_INPUT_RESOURCE::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_MAP_INPUT_RESOURCE, reserved1) - 36usize];
    ["Offset of field: _NV_ENC_MAP_INPUT_RESOURCE::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_MAP_INPUT_RESOURCE, reserved2) - 1040usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_INPUT_RESOURCE_OPENGL_TEX"]
        [::core::mem::size_of::<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX>() - 8usize];
    ["Alignment of _NV_ENC_INPUT_RESOURCE_OPENGL_TEX"]
        [::core::mem::align_of::<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX>() - 4usize];
    ["Offset of field: _NV_ENC_INPUT_RESOURCE_OPENGL_TEX::texture"]
        [::core::mem::offset_of!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX, texture) - 0usize];
    ["Offset of field: _NV_ENC_INPUT_RESOURCE_OPENGL_TEX::target"]
        [::core::mem::offset_of!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX, target) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_FENCE_POINT_D3D12"]
        [::core::mem::size_of::<_NV_ENC_FENCE_POINT_D3D12>() - 64usize];
    ["Alignment of _NV_ENC_FENCE_POINT_D3D12"]
        [::core::mem::align_of::<_NV_ENC_FENCE_POINT_D3D12>() - 8usize];
    ["Offset of field: _NV_ENC_FENCE_POINT_D3D12::version"]
        [::core::mem::offset_of!(_NV_ENC_FENCE_POINT_D3D12, version) - 0usize];
    ["Offset of field: _NV_ENC_FENCE_POINT_D3D12::reserved"]
        [::core::mem::offset_of!(_NV_ENC_FENCE_POINT_D3D12, reserved) - 4usize];
    ["Offset of field: _NV_ENC_FENCE_POINT_D3D12::pFence"]
        [::core::mem::offset_of!(_NV_ENC_FENCE_POINT_D3D12, pFence) - 8usize];
    ["Offset of field: _NV_ENC_FENCE_POINT_D3D12::waitValue"]
        [::core::mem::offset_of!(_NV_ENC_FENCE_POINT_D3D12, waitValue) - 16usize];
    ["Offset of field: _NV_ENC_FENCE_POINT_D3D12::signalValue"]
        [::core::mem::offset_of!(_NV_ENC_FENCE_POINT_D3D12, signalValue) - 24usize];
    ["Offset of field: _NV_ENC_FENCE_POINT_D3D12::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_FENCE_POINT_D3D12, reserved1) - 36usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_INPUT_RESOURCE_D3D12"]
        [::core::mem::size_of::<_NV_ENC_INPUT_RESOURCE_D3D12>() - 272usize];
    ["Alignment of _NV_ENC_INPUT_RESOURCE_D3D12"]
        [::core::mem::align_of::<_NV_ENC_INPUT_RESOURCE_D3D12>() - 8usize];
    ["Offset of field: _NV_ENC_INPUT_RESOURCE_D3D12::version"]
        [::core::mem::offset_of!(_NV_ENC_INPUT_RESOURCE_D3D12, version) - 0usize];
    ["Offset of field: _NV_ENC_INPUT_RESOURCE_D3D12::reserved"]
        [::core::mem::offset_of!(_NV_ENC_INPUT_RESOURCE_D3D12, reserved) - 4usize];
    ["Offset of field: _NV_ENC_INPUT_RESOURCE_D3D12::pInputBuffer"]
        [::core::mem::offset_of!(_NV_ENC_INPUT_RESOURCE_D3D12, pInputBuffer) - 8usize];
    ["Offset of field: _NV_ENC_INPUT_RESOURCE_D3D12::inputFencePoint"]
        [::core::mem::offset_of!(_NV_ENC_INPUT_RESOURCE_D3D12, inputFencePoint) - 16usize];
    ["Offset of field: _NV_ENC_INPUT_RESOURCE_D3D12::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_INPUT_RESOURCE_D3D12, reserved1) - 80usize];
    ["Offset of field: _NV_ENC_INPUT_RESOURCE_D3D12::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_INPUT_RESOURCE_D3D12, reserved2) - 144usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_OUTPUT_RESOURCE_D3D12"]
        [::core::mem::size_of::<_NV_ENC_OUTPUT_RESOURCE_D3D12>() - 272usize];
    ["Alignment of _NV_ENC_OUTPUT_RESOURCE_D3D12"]
        [::core::mem::align_of::<_NV_ENC_OUTPUT_RESOURCE_D3D12>() - 8usize];
    ["Offset of field: _NV_ENC_OUTPUT_RESOURCE_D3D12::version"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_RESOURCE_D3D12, version) - 0usize];
    ["Offset of field: _NV_ENC_OUTPUT_RESOURCE_D3D12::reserved"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_RESOURCE_D3D12, reserved) - 4usize];
    ["Offset of field: _NV_ENC_OUTPUT_RESOURCE_D3D12::pOutputBuffer"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_RESOURCE_D3D12, pOutputBuffer) - 8usize];
    ["Offset of field: _NV_ENC_OUTPUT_RESOURCE_D3D12::outputFencePoint"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_RESOURCE_D3D12, outputFencePoint) - 16usize];
    ["Offset of field: _NV_ENC_OUTPUT_RESOURCE_D3D12::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_RESOURCE_D3D12, reserved1) - 80usize];
    ["Offset of field: _NV_ENC_OUTPUT_RESOURCE_D3D12::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_OUTPUT_RESOURCE_D3D12, reserved2) - 144usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_REGISTER_RESOURCE"]
        [::core::mem::size_of::<_NV_ENC_REGISTER_RESOURCE>() - 1536usize];
    ["Alignment of _NV_ENC_REGISTER_RESOURCE"]
        [::core::mem::align_of::<_NV_ENC_REGISTER_RESOURCE>() - 8usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::version"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, version) - 0usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::resourceType"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, resourceType) - 4usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::width"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, width) - 8usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::height"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, height) - 12usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::pitch"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, pitch) - 16usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::subResourceIndex"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, subResourceIndex) - 20usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::resourceToRegister"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, resourceToRegister) - 24usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::registeredResource"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, registeredResource) - 32usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::bufferFormat"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, bufferFormat) - 40usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::bufferUsage"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, bufferUsage) - 44usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::pInputFencePoint"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, pInputFencePoint) - 48usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::chromaOffset"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, chromaOffset) - 56usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::chromaOffsetIn"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, chromaOffsetIn) - 64usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, reserved1) - 72usize];
    ["Offset of field: _NV_ENC_REGISTER_RESOURCE::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_REGISTER_RESOURCE, reserved2) - 1048usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_STAT"][::core::mem::size_of::<_NV_ENC_STAT>() - 1544usize];
    ["Alignment of _NV_ENC_STAT"][::core::mem::align_of::<_NV_ENC_STAT>() - 8usize];
    ["Offset of field: _NV_ENC_STAT::version"]
        [::core::mem::offset_of!(_NV_ENC_STAT, version) - 0usize];
    ["Offset of field: _NV_ENC_STAT::reserved"]
        [::core::mem::offset_of!(_NV_ENC_STAT, reserved) - 4usize];
    ["Offset of field: _NV_ENC_STAT::outputBitStream"]
        [::core::mem::offset_of!(_NV_ENC_STAT, outputBitStream) - 8usize];
    ["Offset of field: _NV_ENC_STAT::bitStreamSize"]
        [::core::mem::offset_of!(_NV_ENC_STAT, bitStreamSize) - 16usize];
    ["Offset of field: _NV_ENC_STAT::picType"]
        [::core::mem::offset_of!(_NV_ENC_STAT, picType) - 20usize];
    ["Offset of field: _NV_ENC_STAT::lastValidByteOffset"]
        [::core::mem::offset_of!(_NV_ENC_STAT, lastValidByteOffset) - 24usize];
    ["Offset of field: _NV_ENC_STAT::sliceOffsets"]
        [::core::mem::offset_of!(_NV_ENC_STAT, sliceOffsets) - 28usize];
    ["Offset of field: _NV_ENC_STAT::picIdx"]
        [::core::mem::offset_of!(_NV_ENC_STAT, picIdx) - 92usize];
    ["Offset of field: _NV_ENC_STAT::frameAvgQP"]
        [::core::mem::offset_of!(_NV_ENC_STAT, frameAvgQP) - 96usize];
    ["Offset of field: _NV_ENC_STAT::ltrFrameIdx"]
        [::core::mem::offset_of!(_NV_ENC_STAT, ltrFrameIdx) - 104usize];
    ["Offset of field: _NV_ENC_STAT::intraMBCount"]
        [::core::mem::offset_of!(_NV_ENC_STAT, intraMBCount) - 108usize];
    ["Offset of field: _NV_ENC_STAT::interMBCount"]
        [::core::mem::offset_of!(_NV_ENC_STAT, interMBCount) - 112usize];
    ["Offset of field: _NV_ENC_STAT::averageMVX"]
        [::core::mem::offset_of!(_NV_ENC_STAT, averageMVX) - 116usize];
    ["Offset of field: _NV_ENC_STAT::averageMVY"]
        [::core::mem::offset_of!(_NV_ENC_STAT, averageMVY) - 120usize];
    ["Offset of field: _NV_ENC_STAT::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_STAT, reserved1) - 124usize];
    ["Offset of field: _NV_ENC_STAT::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_STAT, reserved2) - 1032usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_SEQUENCE_PARAM_PAYLOAD"]
        [::core::mem::size_of::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>() - 1544usize];
    ["Alignment of _NV_ENC_SEQUENCE_PARAM_PAYLOAD"]
        [::core::mem::align_of::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>() - 8usize];
    ["Offset of field: _NV_ENC_SEQUENCE_PARAM_PAYLOAD::version"]
        [::core::mem::offset_of!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD, version) - 0usize];
    ["Offset of field: _NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize"]
        [::core::mem::offset_of!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD, inBufferSize) - 4usize];
    ["Offset of field: _NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsId"]
        [::core::mem::offset_of!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD, spsId) - 8usize];
    ["Offset of field: _NV_ENC_SEQUENCE_PARAM_PAYLOAD::ppsId"]
        [::core::mem::offset_of!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD, ppsId) - 12usize];
    ["Offset of field: _NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsppsBuffer"]
        [::core::mem::offset_of!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD, spsppsBuffer) - 16usize];
    ["Offset of field: _NV_ENC_SEQUENCE_PARAM_PAYLOAD::outSPSPPSPayloadSize"]
        [::core::mem::offset_of!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD, outSPSPPSPayloadSize) - 24usize];
    ["Offset of field: _NV_ENC_SEQUENCE_PARAM_PAYLOAD::reserved"]
        [::core::mem::offset_of!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD, reserved) - 32usize];
    ["Offset of field: _NV_ENC_SEQUENCE_PARAM_PAYLOAD::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD, reserved2) - 1032usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_EVENT_PARAMS"][::core::mem::size_of::<_NV_ENC_EVENT_PARAMS>() - 1544usize];
    ["Alignment of _NV_ENC_EVENT_PARAMS"][::core::mem::align_of::<_NV_ENC_EVENT_PARAMS>() - 8usize];
    ["Offset of field: _NV_ENC_EVENT_PARAMS::version"]
        [::core::mem::offset_of!(_NV_ENC_EVENT_PARAMS, version) - 0usize];
    ["Offset of field: _NV_ENC_EVENT_PARAMS::reserved"]
        [::core::mem::offset_of!(_NV_ENC_EVENT_PARAMS, reserved) - 4usize];
    ["Offset of field: _NV_ENC_EVENT_PARAMS::completionEvent"]
        [::core::mem::offset_of!(_NV_ENC_EVENT_PARAMS, completionEvent) - 8usize];
    ["Offset of field: _NV_ENC_EVENT_PARAMS::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_EVENT_PARAMS, reserved1) - 16usize];
    ["Offset of field: _NV_ENC_EVENT_PARAMS::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_EVENT_PARAMS, reserved2) - 1032usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS"]
        [::core::mem::size_of::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>() - 1552usize];
    ["Alignment of _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS"]
        [::core::mem::align_of::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>() - 8usize];
    ["Offset of field: _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::version"]
        [::core::mem::offset_of!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS, version) - 0usize];
    ["Offset of field: _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::deviceType"]
        [::core::mem::offset_of!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS, deviceType) - 4usize];
    ["Offset of field: _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::device"]
        [::core::mem::offset_of!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS, device) - 8usize];
    ["Offset of field: _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::reserved"]
        [::core::mem::offset_of!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS, reserved) - 16usize];
    ["Offset of field: _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::apiVersion"]
        [::core::mem::offset_of!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS, apiVersion) - 24usize];
    ["Offset of field: _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::reserved1"]
        [::core::mem::offset_of!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS, reserved1) - 28usize];
    ["Offset of field: _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::reserved2"]
        [::core::mem::offset_of!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS, reserved2) - 1040usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NV_ENCODE_API_FUNCTION_LIST"]
        [::core::mem::size_of::<_NV_ENCODE_API_FUNCTION_LIST>() - 2552usize];
    ["Alignment of _NV_ENCODE_API_FUNCTION_LIST"]
        [::core::mem::align_of::<_NV_ENCODE_API_FUNCTION_LIST>() - 8usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::version"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, version) - 0usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::reserved"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, reserved) - 4usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncOpenEncodeSession"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncOpenEncodeSession) - 8usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeGUIDCount"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncGetEncodeGUIDCount) - 16usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeProfileGUIDCount"][::core::mem::offset_of!(
        _NV_ENCODE_API_FUNCTION_LIST,
        nvEncGetEncodeProfileGUIDCount
    ) - 24usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeProfileGUIDs"][::core::mem::offset_of!(
        _NV_ENCODE_API_FUNCTION_LIST,
        nvEncGetEncodeProfileGUIDs
    ) - 32usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeGUIDs"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncGetEncodeGUIDs) - 40usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetInputFormatCount"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncGetInputFormatCount) - 48usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetInputFormats"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncGetInputFormats) - 56usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeCaps"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncGetEncodeCaps) - 64usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodePresetCount"][::core::mem::offset_of!(
        _NV_ENCODE_API_FUNCTION_LIST,
        nvEncGetEncodePresetCount
    ) - 72usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodePresetGUIDs"][::core::mem::offset_of!(
        _NV_ENCODE_API_FUNCTION_LIST,
        nvEncGetEncodePresetGUIDs
    ) - 80usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodePresetConfig"][::core::mem::offset_of!(
        _NV_ENCODE_API_FUNCTION_LIST,
        nvEncGetEncodePresetConfig
    ) - 88usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncInitializeEncoder"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncInitializeEncoder) - 96usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncCreateInputBuffer"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncCreateInputBuffer) - 104usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyInputBuffer"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncDestroyInputBuffer) - 112usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncCreateBitstreamBuffer"][::core::mem::offset_of!(
        _NV_ENCODE_API_FUNCTION_LIST,
        nvEncCreateBitstreamBuffer
    ) - 120usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyBitstreamBuffer"][::core::mem::offset_of!(
        _NV_ENCODE_API_FUNCTION_LIST,
        nvEncDestroyBitstreamBuffer
    ) - 128usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncEncodePicture"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncEncodePicture) - 136usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncLockBitstream"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncLockBitstream) - 144usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncUnlockBitstream"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncUnlockBitstream) - 152usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncLockInputBuffer"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncLockInputBuffer) - 160usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncUnlockInputBuffer"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncUnlockInputBuffer) - 168usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeStats"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncGetEncodeStats) - 176usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetSequenceParams"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncGetSequenceParams) - 184usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncRegisterAsyncEvent"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncRegisterAsyncEvent) - 192usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncUnregisterAsyncEvent"][::core::mem::offset_of!(
        _NV_ENCODE_API_FUNCTION_LIST,
        nvEncUnregisterAsyncEvent
    ) - 200usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncMapInputResource"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncMapInputResource) - 208usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncUnmapInputResource"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncUnmapInputResource) - 216usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyEncoder"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncDestroyEncoder) - 224usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncInvalidateRefFrames"][::core::mem::offset_of!(
        _NV_ENCODE_API_FUNCTION_LIST,
        nvEncInvalidateRefFrames
    ) - 232usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncOpenEncodeSessionEx"][::core::mem::offset_of!(
        _NV_ENCODE_API_FUNCTION_LIST,
        nvEncOpenEncodeSessionEx
    ) - 240usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncRegisterResource"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncRegisterResource) - 248usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncUnregisterResource"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncUnregisterResource) - 256usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncReconfigureEncoder"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncReconfigureEncoder) - 264usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::reserved1"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, reserved1) - 272usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncCreateMVBuffer"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncCreateMVBuffer) - 280usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyMVBuffer"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncDestroyMVBuffer) - 288usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncRunMotionEstimationOnly"][::core::mem::offset_of!(
        _NV_ENCODE_API_FUNCTION_LIST,
        nvEncRunMotionEstimationOnly
    ) - 296usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetLastErrorString"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncGetLastErrorString) - 304usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncSetIOCudaStreams"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncSetIOCudaStreams) - 312usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodePresetConfigEx"][::core::mem::offset_of!(
        _NV_ENCODE_API_FUNCTION_LIST,
        nvEncGetEncodePresetConfigEx
    ) - 320usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncGetSequenceParamEx"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncGetSequenceParamEx) - 328usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncRestoreEncoderState"][::core::mem::offset_of!(
        _NV_ENCODE_API_FUNCTION_LIST,
        nvEncRestoreEncoderState
    ) - 336usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::nvEncLookaheadPicture"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, nvEncLookaheadPicture) - 344usize];
    ["Offset of field: _NV_ENCODE_API_FUNCTION_LIST::reserved2"]
        [::core::mem::offset_of!(_NV_ENCODE_API_FUNCTION_LIST, reserved2) - 352usize];
};
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PARAMS_FRAME_FIELD_MODE {
    NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME = 1,
    NV_ENC_PARAMS_FRAME_FIELD_MODE_FIELD = 2,
    NV_ENC_PARAMS_FRAME_FIELD_MODE_MBAFF = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PARAMS_RC_MODE {
    NV_ENC_PARAMS_RC_CONSTQP = 0,
    NV_ENC_PARAMS_RC_VBR = 1,
    NV_ENC_PARAMS_RC_CBR = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_MULTI_PASS {
    NV_ENC_MULTI_PASS_DISABLED = 0,
    NV_ENC_TWO_PASS_QUARTER_RESOLUTION = 1,
    NV_ENC_TWO_PASS_FULL_RESOLUTION = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_STATE_RESTORE_TYPE {
    NV_ENC_STATE_RESTORE_FULL = 1,
    NV_ENC_STATE_RESTORE_RATE_CONTROL = 2,
    NV_ENC_STATE_RESTORE_ENCODE = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_OUTPUT_STATS_LEVEL {
    NV_ENC_OUTPUT_STATS_NONE = 0,
    NV_ENC_OUTPUT_STATS_BLOCK_LEVEL = 1,
    NV_ENC_OUTPUT_STATS_ROW_LEVEL = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_EMPHASIS_MAP_LEVEL {
    NV_ENC_EMPHASIS_MAP_LEVEL_0 = 0,
    NV_ENC_EMPHASIS_MAP_LEVEL_1 = 1,
    NV_ENC_EMPHASIS_MAP_LEVEL_2 = 2,
    NV_ENC_EMPHASIS_MAP_LEVEL_3 = 3,
    NV_ENC_EMPHASIS_MAP_LEVEL_4 = 4,
    NV_ENC_EMPHASIS_MAP_LEVEL_5 = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_QP_MAP_MODE {
    NV_ENC_QP_MAP_DISABLED = 0,
    NV_ENC_QP_MAP_EMPHASIS = 1,
    NV_ENC_QP_MAP_DELTA = 2,
    NV_ENC_QP_MAP = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PIC_STRUCT {
    NV_ENC_PIC_STRUCT_FRAME = 1,
    NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM = 2,
    NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_DISPLAY_PIC_STRUCT {
    NV_ENC_PIC_STRUCT_DISPLAY_FRAME = 0,
    NV_ENC_PIC_STRUCT_DISPLAY_FIELD_TOP_BOTTOM = 1,
    NV_ENC_PIC_STRUCT_DISPLAY_FIELD_BOTTOM_TOP = 2,
    NV_ENC_PIC_STRUCT_DISPLAY_FRAME_DOUBLING = 3,
    NV_ENC_PIC_STRUCT_DISPLAY_FRAME_TRIPLING = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PIC_TYPE {
    NV_ENC_PIC_TYPE_P = 0,
    NV_ENC_PIC_TYPE_B = 1,
    NV_ENC_PIC_TYPE_I = 2,
    NV_ENC_PIC_TYPE_IDR = 3,
    NV_ENC_PIC_TYPE_BI = 4,
    NV_ENC_PIC_TYPE_SKIPPED = 5,
    NV_ENC_PIC_TYPE_INTRA_REFRESH = 6,
    NV_ENC_PIC_TYPE_NONREF_P = 7,
    NV_ENC_PIC_TYPE_SWITCH = 8,
    NV_ENC_PIC_TYPE_UNKNOWN = 255,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_MV_PRECISION {
    NV_ENC_MV_PRECISION_DEFAULT = 0,
    NV_ENC_MV_PRECISION_FULL_PEL = 1,
    NV_ENC_MV_PRECISION_HALF_PEL = 2,
    NV_ENC_MV_PRECISION_QUARTER_PEL = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_BUFFER_FORMAT {
    NV_ENC_BUFFER_FORMAT_UNDEFINED = 0,
    NV_ENC_BUFFER_FORMAT_NV12 = 1,
    NV_ENC_BUFFER_FORMAT_YV12 = 16,
    NV_ENC_BUFFER_FORMAT_IYUV = 256,
    NV_ENC_BUFFER_FORMAT_YUV444 = 4096,
    NV_ENC_BUFFER_FORMAT_YUV420_10BIT = 65536,
    NV_ENC_BUFFER_FORMAT_YUV444_10BIT = 1048576,
    NV_ENC_BUFFER_FORMAT_ARGB = 16777216,
    NV_ENC_BUFFER_FORMAT_ARGB10 = 33554432,
    NV_ENC_BUFFER_FORMAT_AYUV = 67108864,
    NV_ENC_BUFFER_FORMAT_ABGR = 268435456,
    NV_ENC_BUFFER_FORMAT_ABGR10 = 536870912,
    NV_ENC_BUFFER_FORMAT_U8 = 1073741824,
    NV_ENC_BUFFER_FORMAT_NV16 = 1073741825,
    NV_ENC_BUFFER_FORMAT_P210 = 1073741826,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_LEVEL {
    NV_ENC_LEVEL_AUTOSELECT = 0,
    NV_ENC_LEVEL_H264_1 = 10,
    NV_ENC_LEVEL_H264_1b = 9,
    NV_ENC_LEVEL_H264_11 = 11,
    NV_ENC_LEVEL_H264_12 = 12,
    NV_ENC_LEVEL_H264_13 = 13,
    NV_ENC_LEVEL_H264_2 = 20,
    NV_ENC_LEVEL_H264_21 = 21,
    NV_ENC_LEVEL_H264_22 = 22,
    NV_ENC_LEVEL_H264_3 = 30,
    NV_ENC_LEVEL_H264_31 = 31,
    NV_ENC_LEVEL_H264_32 = 32,
    NV_ENC_LEVEL_H264_4 = 40,
    NV_ENC_LEVEL_H264_41 = 41,
    NV_ENC_LEVEL_H264_42 = 42,
    NV_ENC_LEVEL_H264_5 = 50,
    NV_ENC_LEVEL_H264_51 = 51,
    NV_ENC_LEVEL_H264_52 = 52,
    NV_ENC_LEVEL_H264_60 = 60,
    NV_ENC_LEVEL_H264_61 = 61,
    NV_ENC_LEVEL_H264_62 = 62,
    NV_ENC_LEVEL_HEVC_21 = 63,
    NV_ENC_LEVEL_HEVC_3 = 90,
    NV_ENC_LEVEL_HEVC_31 = 93,
    NV_ENC_LEVEL_HEVC_4 = 120,
    NV_ENC_LEVEL_HEVC_41 = 123,
    NV_ENC_LEVEL_HEVC_5 = 150,
    NV_ENC_LEVEL_HEVC_51 = 153,
    NV_ENC_LEVEL_HEVC_52 = 156,
    NV_ENC_LEVEL_HEVC_6 = 180,
    NV_ENC_LEVEL_HEVC_61 = 183,
    NV_ENC_LEVEL_HEVC_62 = 186,
    NV_ENC_TIER_HEVC_HIGH = 1,
    NV_ENC_LEVEL_AV1_22 = 2,
    NV_ENC_LEVEL_AV1_23 = 3,
    NV_ENC_LEVEL_AV1_3 = 4,
    NV_ENC_LEVEL_AV1_31 = 5,
    NV_ENC_LEVEL_AV1_32 = 6,
    NV_ENC_LEVEL_AV1_33 = 7,
    NV_ENC_LEVEL_AV1_4 = 8,
    NV_ENC_LEVEL_AV1_52 = 14,
    NV_ENC_LEVEL_AV1_53 = 15,
    NV_ENC_LEVEL_AV1_6 = 16,
    NV_ENC_LEVEL_AV1_61 = 17,
    NV_ENC_LEVEL_AV1_62 = 18,
    NV_ENC_LEVEL_AV1_63 = 19,
    NV_ENC_LEVEL_AV1_73 = 23,
    NV_ENC_LEVEL_AV1_AUTOSELECT = 24,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NVENCSTATUS {
    NV_ENC_SUCCESS = 0,
    NV_ENC_ERR_NO_ENCODE_DEVICE = 1,
    NV_ENC_ERR_UNSUPPORTED_DEVICE = 2,
    NV_ENC_ERR_INVALID_ENCODERDEVICE = 3,
    NV_ENC_ERR_INVALID_DEVICE = 4,
    NV_ENC_ERR_DEVICE_NOT_EXIST = 5,
    NV_ENC_ERR_INVALID_PTR = 6,
    NV_ENC_ERR_INVALID_EVENT = 7,
    NV_ENC_ERR_INVALID_PARAM = 8,
    NV_ENC_ERR_INVALID_CALL = 9,
    NV_ENC_ERR_OUT_OF_MEMORY = 10,
    NV_ENC_ERR_ENCODER_NOT_INITIALIZED = 11,
    NV_ENC_ERR_UNSUPPORTED_PARAM = 12,
    NV_ENC_ERR_LOCK_BUSY = 13,
    NV_ENC_ERR_NOT_ENOUGH_BUFFER = 14,
    NV_ENC_ERR_INVALID_VERSION = 15,
    NV_ENC_ERR_MAP_FAILED = 16,
    NV_ENC_ERR_NEED_MORE_INPUT = 17,
    NV_ENC_ERR_ENCODER_BUSY = 18,
    NV_ENC_ERR_EVENT_NOT_REGISTERD = 19,
    NV_ENC_ERR_GENERIC = 20,
    NV_ENC_ERR_INCOMPATIBLE_CLIENT_KEY = 21,
    NV_ENC_ERR_UNIMPLEMENTED = 22,
    NV_ENC_ERR_RESOURCE_REGISTER_FAILED = 23,
    NV_ENC_ERR_RESOURCE_NOT_REGISTERED = 24,
    NV_ENC_ERR_RESOURCE_NOT_MAPPED = 25,
    NV_ENC_ERR_NEED_MORE_OUTPUT = 26,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PIC_FLAGS {
    NV_ENC_PIC_FLAG_FORCEINTRA = 1,
    NV_ENC_PIC_FLAG_FORCEIDR = 2,
    NV_ENC_PIC_FLAG_OUTPUT_SPSPPS = 4,
    NV_ENC_PIC_FLAG_EOS = 8,
    NV_ENC_PIC_FLAG_DISABLE_ENC_STATE_ADVANCE = 16,
    NV_ENC_PIC_FLAG_OUTPUT_RECON_FRAME = 32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_MEMORY_HEAP {
    NV_ENC_MEMORY_HEAP_AUTOSELECT = 0,
    NV_ENC_MEMORY_HEAP_VID = 1,
    NV_ENC_MEMORY_HEAP_SYSMEM_CACHED = 2,
    NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_BFRAME_REF_MODE {
    NV_ENC_BFRAME_REF_MODE_DISABLED = 0,
    NV_ENC_BFRAME_REF_MODE_EACH = 1,
    NV_ENC_BFRAME_REF_MODE_MIDDLE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_H264_ENTROPY_CODING_MODE {
    NV_ENC_H264_ENTROPY_CODING_MODE_AUTOSELECT = 0,
    NV_ENC_H264_ENTROPY_CODING_MODE_CABAC = 1,
    NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_H264_BDIRECT_MODE {
    NV_ENC_H264_BDIRECT_MODE_AUTOSELECT = 0,
    NV_ENC_H264_BDIRECT_MODE_DISABLE = 1,
    NV_ENC_H264_BDIRECT_MODE_TEMPORAL = 2,
    NV_ENC_H264_BDIRECT_MODE_SPATIAL = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_H264_FMO_MODE {
    NV_ENC_H264_FMO_AUTOSELECT = 0,
    NV_ENC_H264_FMO_ENABLE = 1,
    NV_ENC_H264_FMO_DISABLE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE {
    NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT = 0,
    NV_ENC_H264_ADAPTIVE_TRANSFORM_DISABLE = 1,
    NV_ENC_H264_ADAPTIVE_TRANSFORM_ENABLE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_STEREO_PACKING_MODE {
    NV_ENC_STEREO_PACKING_MODE_NONE = 0,
    NV_ENC_STEREO_PACKING_MODE_CHECKERBOARD = 1,
    NV_ENC_STEREO_PACKING_MODE_COLINTERLEAVE = 2,
    NV_ENC_STEREO_PACKING_MODE_ROWINTERLEAVE = 3,
    NV_ENC_STEREO_PACKING_MODE_SIDEBYSIDE = 4,
    NV_ENC_STEREO_PACKING_MODE_TOPBOTTOM = 5,
    NV_ENC_STEREO_PACKING_MODE_FRAMESEQ = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_INPUT_RESOURCE_TYPE {
    NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX = 0,
    NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR = 1,
    NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY = 2,
    NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_BUFFER_USAGE {
    NV_ENC_INPUT_IMAGE = 0,
    NV_ENC_OUTPUT_MOTION_VECTOR = 1,
    NV_ENC_OUTPUT_BITSTREAM = 2,
    NV_ENC_OUTPUT_RECON = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_DEVICE_TYPE {
    NV_ENC_DEVICE_TYPE_DIRECTX = 0,
    NV_ENC_DEVICE_TYPE_CUDA = 1,
    NV_ENC_DEVICE_TYPE_OPENGL = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_NUM_REF_FRAMES {
    NV_ENC_NUM_REF_FRAMES_AUTOSELECT = 0,
    NV_ENC_NUM_REF_FRAMES_1 = 1,
    NV_ENC_NUM_REF_FRAMES_2 = 2,
    NV_ENC_NUM_REF_FRAMES_3 = 3,
    NV_ENC_NUM_REF_FRAMES_4 = 4,
    NV_ENC_NUM_REF_FRAMES_5 = 5,
    NV_ENC_NUM_REF_FRAMES_6 = 6,
    NV_ENC_NUM_REF_FRAMES_7 = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_TEMPORAL_FILTER_LEVEL {
    NV_ENC_TEMPORAL_FILTER_LEVEL_0 = 0,
    NV_ENC_TEMPORAL_FILTER_LEVEL_4 = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_CAPS {
    NV_ENC_CAPS_NUM_MAX_BFRAMES = 0,
    NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES = 1,
    NV_ENC_CAPS_SUPPORT_FIELD_ENCODING = 2,
    NV_ENC_CAPS_SUPPORT_MONOCHROME = 3,
    NV_ENC_CAPS_SUPPORT_FMO = 4,
    NV_ENC_CAPS_SUPPORT_QPELMV = 5,
    NV_ENC_CAPS_SUPPORT_BDIRECT_MODE = 6,
    NV_ENC_CAPS_SUPPORT_CABAC = 7,
    NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM = 8,
    NV_ENC_CAPS_SUPPORT_STEREO_MVC = 9,
    NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS = 10,
    NV_ENC_CAPS_SUPPORT_HIERARCHICAL_PFRAMES = 11,
    NV_ENC_CAPS_SUPPORT_HIERARCHICAL_BFRAMES = 12,
    NV_ENC_CAPS_LEVEL_MAX = 13,
    NV_ENC_CAPS_LEVEL_MIN = 14,
    NV_ENC_CAPS_SEPARATE_COLOUR_PLANE = 15,
    NV_ENC_CAPS_WIDTH_MAX = 16,
    NV_ENC_CAPS_HEIGHT_MAX = 17,
    NV_ENC_CAPS_SUPPORT_TEMPORAL_SVC = 18,
    NV_ENC_CAPS_SUPPORT_DYN_RES_CHANGE = 19,
    NV_ENC_CAPS_SUPPORT_DYN_BITRATE_CHANGE = 20,
    NV_ENC_CAPS_SUPPORT_DYN_FORCE_CONSTQP = 21,
    NV_ENC_CAPS_SUPPORT_DYN_RCMODE_CHANGE = 22,
    NV_ENC_CAPS_SUPPORT_SUBFRAME_READBACK = 23,
    NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING = 24,
    NV_ENC_CAPS_SUPPORT_INTRA_REFRESH = 25,
    NV_ENC_CAPS_SUPPORT_CUSTOM_VBV_BUF_SIZE = 26,
    NV_ENC_CAPS_SUPPORT_DYNAMIC_SLICE_MODE = 27,
    NV_ENC_CAPS_SUPPORT_REF_PIC_INVALIDATION = 28,
    NV_ENC_CAPS_PREPROC_SUPPORT = 29,
    NV_ENC_CAPS_ASYNC_ENCODE_SUPPORT = 30,
    NV_ENC_CAPS_MB_NUM_MAX = 31,
    NV_ENC_CAPS_MB_PER_SEC_MAX = 32,
    NV_ENC_CAPS_SUPPORT_YUV444_ENCODE = 33,
    NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE = 34,
    NV_ENC_CAPS_SUPPORT_SAO = 35,
    NV_ENC_CAPS_SUPPORT_MEONLY_MODE = 36,
    NV_ENC_CAPS_SUPPORT_LOOKAHEAD = 37,
    NV_ENC_CAPS_SUPPORT_TEMPORAL_AQ = 38,
    NV_ENC_CAPS_SUPPORT_10BIT_ENCODE = 39,
    NV_ENC_CAPS_NUM_MAX_LTR_FRAMES = 40,
    NV_ENC_CAPS_SUPPORT_WEIGHTED_PREDICTION = 41,
    NV_ENC_CAPS_DYNAMIC_QUERY_ENCODER_CAPACITY = 42,
    NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE = 43,
    NV_ENC_CAPS_SUPPORT_EMPHASIS_LEVEL_MAP = 44,
    NV_ENC_CAPS_WIDTH_MIN = 45,
    NV_ENC_CAPS_HEIGHT_MIN = 46,
    NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES = 47,
    NV_ENC_CAPS_SUPPORT_ALPHA_LAYER_ENCODING = 48,
    NV_ENC_CAPS_NUM_ENCODER_ENGINES = 49,
    NV_ENC_CAPS_SINGLE_SLICE_INTRA_REFRESH = 50,
    NV_ENC_CAPS_DISABLE_ENC_STATE_ADVANCE = 51,
    NV_ENC_CAPS_OUTPUT_RECON_SURFACE = 52,
    NV_ENC_CAPS_OUTPUT_BLOCK_STATS = 53,
    NV_ENC_CAPS_OUTPUT_ROW_STATS = 54,
    NV_ENC_CAPS_SUPPORT_TEMPORAL_FILTER = 55,
    NV_ENC_CAPS_SUPPORT_LOOKAHEAD_LEVEL = 56,
    NV_ENC_CAPS_SUPPORT_UNIDIRECTIONAL_B = 57,
    NV_ENC_CAPS_SUPPORT_MVHEVC_ENCODE = 58,
    NV_ENC_CAPS_SUPPORT_YUV422_ENCODE = 59,
    NV_ENC_CAPS_EXPOSED_COUNT = 60,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_HEVC_CUSIZE {
    NV_ENC_HEVC_CUSIZE_AUTOSELECT = 0,
    NV_ENC_HEVC_CUSIZE_8x8 = 1,
    NV_ENC_HEVC_CUSIZE_16x16 = 2,
    NV_ENC_HEVC_CUSIZE_32x32 = 3,
    NV_ENC_HEVC_CUSIZE_64x64 = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_AV1_PART_SIZE {
    NV_ENC_AV1_PART_SIZE_AUTOSELECT = 0,
    NV_ENC_AV1_PART_SIZE_4x4 = 1,
    NV_ENC_AV1_PART_SIZE_8x8 = 2,
    NV_ENC_AV1_PART_SIZE_16x16 = 3,
    NV_ENC_AV1_PART_SIZE_32x32 = 4,
    NV_ENC_AV1_PART_SIZE_64x64 = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_VUI_VIDEO_FORMAT {
    NV_ENC_VUI_VIDEO_FORMAT_COMPONENT = 0,
    NV_ENC_VUI_VIDEO_FORMAT_PAL = 1,
    NV_ENC_VUI_VIDEO_FORMAT_NTSC = 2,
    NV_ENC_VUI_VIDEO_FORMAT_SECAM = 3,
    NV_ENC_VUI_VIDEO_FORMAT_MAC = 4,
    NV_ENC_VUI_VIDEO_FORMAT_UNSPECIFIED = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_VUI_COLOR_PRIMARIES {
    NV_ENC_VUI_COLOR_PRIMARIES_UNDEFINED = 0,
    NV_ENC_VUI_COLOR_PRIMARIES_BT709 = 1,
    NV_ENC_VUI_COLOR_PRIMARIES_UNSPECIFIED = 2,
    NV_ENC_VUI_COLOR_PRIMARIES_RESERVED = 3,
    NV_ENC_VUI_COLOR_PRIMARIES_BT470M = 4,
    NV_ENC_VUI_COLOR_PRIMARIES_BT470BG = 5,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE170M = 6,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE240M = 7,
    NV_ENC_VUI_COLOR_PRIMARIES_FILM = 8,
    NV_ENC_VUI_COLOR_PRIMARIES_BT2020 = 9,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE428 = 10,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE431 = 11,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE432 = 12,
    NV_ENC_VUI_COLOR_PRIMARIES_JEDEC_P22 = 22,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_VUI_TRANSFER_CHARACTERISTIC {
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_UNDEFINED = 0,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT709 = 1,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_UNSPECIFIED = 2,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_RESERVED = 3,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT470M = 4,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT470BG = 5,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE170M = 6,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE240M = 7,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_LINEAR = 8,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_LOG = 9,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_LOG_SQRT = 10,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_IEC61966_2_4 = 11,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT1361_ECG = 12,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SRGB = 13,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT2020_10 = 14,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT2020_12 = 15,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE2084 = 16,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE428 = 17,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_ARIB_STD_B67 = 18,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_VUI_MATRIX_COEFFS {
    NV_ENC_VUI_MATRIX_COEFFS_RGB = 0,
    NV_ENC_VUI_MATRIX_COEFFS_BT709 = 1,
    NV_ENC_VUI_MATRIX_COEFFS_UNSPECIFIED = 2,
    NV_ENC_VUI_MATRIX_COEFFS_RESERVED = 3,
    NV_ENC_VUI_MATRIX_COEFFS_FCC = 4,
    NV_ENC_VUI_MATRIX_COEFFS_BT470BG = 5,
    NV_ENC_VUI_MATRIX_COEFFS_SMPTE170M = 6,
    NV_ENC_VUI_MATRIX_COEFFS_SMPTE240M = 7,
    NV_ENC_VUI_MATRIX_COEFFS_YCGCO = 8,
    NV_ENC_VUI_MATRIX_COEFFS_BT2020_NCL = 9,
    NV_ENC_VUI_MATRIX_COEFFS_BT2020_CL = 10,
    NV_ENC_VUI_MATRIX_COEFFS_SMPTE2085 = 11,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_LOOKAHEAD_LEVEL {
    NV_ENC_LOOKAHEAD_LEVEL_0 = 0,
    NV_ENC_LOOKAHEAD_LEVEL_1 = 1,
    NV_ENC_LOOKAHEAD_LEVEL_2 = 2,
    NV_ENC_LOOKAHEAD_LEVEL_3 = 3,
    NV_ENC_LOOKAHEAD_LEVEL_AUTOSELECT = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_BIT_DEPTH {
    NV_ENC_BIT_DEPTH_INVALID = 0,
    NV_ENC_BIT_DEPTH_8 = 8,
    NV_ENC_BIT_DEPTH_10 = 10,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum NV_ENC_TUNING_INFO {
    NV_ENC_TUNING_INFO_UNDEFINED = 0,
    NV_ENC_TUNING_INFO_HIGH_QUALITY = 1,
    NV_ENC_TUNING_INFO_LOW_LATENCY = 2,
    NV_ENC_TUNING_INFO_ULTRA_LOW_LATENCY = 3,
    NV_ENC_TUNING_INFO_LOSSLESS = 4,
    NV_ENC_TUNING_INFO_ULTRA_HIGH_QUALITY = 5,
    NV_ENC_TUNING_INFO_COUNT = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_SPLIT_ENCODE_MODE {
    NV_ENC_SPLIT_AUTO_MODE = 0,
    NV_ENC_SPLIT_AUTO_FORCED_MODE = 1,
    NV_ENC_SPLIT_TWO_FORCED_MODE = 2,
    NV_ENC_SPLIT_THREE_FORCED_MODE = 3,
    NV_ENC_SPLIT_FOUR_FORCED_MODE = 4,
    NV_ENC_SPLIT_DISABLE_MODE = 15,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_CONFIG {
    pub h264Config: NV_ENC_CONFIG_H264,
    pub hevcConfig: NV_ENC_CONFIG_HEVC,
    pub av1Config: NV_ENC_CONFIG_AV1,
    pub h264MeOnlyConfig: NV_ENC_CONFIG_H264_MEONLY,
    pub hevcMeOnlyConfig: NV_ENC_CONFIG_HEVC_MEONLY,
    pub reserved: [u32; 320usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_PIC_PARAMS_H264_EXT {
    pub mvcPicParams: NV_ENC_PIC_PARAMS_MVC,
    pub reserved1: [u32; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_PIC_PARAMS {
    pub h264PicParams: NV_ENC_PIC_PARAMS_H264,
    pub hevcPicParams: NV_ENC_PIC_PARAMS_HEVC,
    pub av1PicParams: NV_ENC_PIC_PARAMS_AV1,
    pub reserved: [u32; 256usize],
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_HEVC_1: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_3;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_HEVC_2: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_60;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_TIER_HEVC_MAIN: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_AUTOSELECT;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_2: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_AUTOSELECT;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_21: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_TIER_HEVC_HIGH;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_41: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_1b;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_42: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_1;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_43: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_11;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_5: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_12;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_51: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_13;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_7: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_2;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_71: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_21;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_72: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_22;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_TIER_AV1_0: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_AUTOSELECT;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_TIER_AV1_1: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_TIER_HEVC_HIGH;
}
impl Default for _NV_ENC_CAPS_PARAM {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_RESTORE_ENCODER_STATE_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_ENCODE_OUT_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_LOOKAHEAD_PIC_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_CREATE_INPUT_BUFFER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_CREATE_BITSTREAM_BUFFER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_CREATE_MV_BUFFER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_RC_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_RC_PARAMS {
    #[inline]
    pub fn enableMinQP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMinQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableMinQP_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableMinQP_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableMaxQP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMaxQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableMaxQP_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableMaxQP_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableInitialRCQP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableInitialRCQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableInitialRCQP_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableInitialRCQP_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableAQ(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableAQ_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableAQ_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitField1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitField1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitField1_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitField1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableLookahead(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLookahead(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableLookahead_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableLookahead_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableIadapt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableIadapt_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableIadapt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableBadapt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableBadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableBadapt_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableBadapt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableTemporalAQ(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableTemporalAQ_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableTemporalAQ_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn zeroReorderDelay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zeroReorderDelay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn zeroReorderDelay_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_zeroReorderDelay_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableNonRefP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableNonRefP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableNonRefP_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableNonRefP_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn strictGOPTarget(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strictGOPTarget(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn strictGOPTarget_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_strictGOPTarget_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn aqStrength(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_aqStrength(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn aqStrength_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_aqStrength_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableExtLookahead(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableExtLookahead(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableExtLookahead_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableExtLookahead_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                15u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableMinQP: u32,
        enableMaxQP: u32,
        enableInitialRCQP: u32,
        enableAQ: u32,
        reservedBitField1: u32,
        enableLookahead: u32,
        disableIadapt: u32,
        disableBadapt: u32,
        enableTemporalAQ: u32,
        zeroReorderDelay: u32,
        enableNonRefP: u32,
        strictGOPTarget: u32,
        aqStrength: u32,
        enableExtLookahead: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableMinQP: u32 = unsafe { ::core::mem::transmute(enableMinQP) };
            enableMinQP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableMaxQP: u32 = unsafe { ::core::mem::transmute(enableMaxQP) };
            enableMaxQP as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableInitialRCQP: u32 = unsafe { ::core::mem::transmute(enableInitialRCQP) };
            enableInitialRCQP as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableAQ: u32 = unsafe { ::core::mem::transmute(enableAQ) };
            enableAQ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reservedBitField1: u32 = unsafe { ::core::mem::transmute(reservedBitField1) };
            reservedBitField1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLookahead: u32 = unsafe { ::core::mem::transmute(enableLookahead) };
            enableLookahead as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableIadapt: u32 = unsafe { ::core::mem::transmute(disableIadapt) };
            disableIadapt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableBadapt: u32 = unsafe { ::core::mem::transmute(disableBadapt) };
            disableBadapt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableTemporalAQ: u32 = unsafe { ::core::mem::transmute(enableTemporalAQ) };
            enableTemporalAQ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let zeroReorderDelay: u32 = unsafe { ::core::mem::transmute(zeroReorderDelay) };
            zeroReorderDelay as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableNonRefP: u32 = unsafe { ::core::mem::transmute(enableNonRefP) };
            enableNonRefP as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let strictGOPTarget: u32 = unsafe { ::core::mem::transmute(strictGOPTarget) };
            strictGOPTarget as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let aqStrength: u32 = unsafe { ::core::mem::transmute(aqStrength) };
            aqStrength as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let enableExtLookahead: u32 = unsafe { ::core::mem::transmute(enableExtLookahead) };
            enableExtLookahead as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _NV_ENC_CLOCK_TIMESTAMP_SET {
    #[inline]
    pub fn countingType(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_countingType(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn countingType_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_countingType_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn discontinuityFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_discontinuityFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn discontinuityFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_discontinuityFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cntDroppedFrames(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cntDroppedFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cntDroppedFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cntDroppedFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nFrames(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_nFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn secondsValue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_secondsValue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn secondsValue_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_secondsValue_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn minutesValue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_minutesValue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn minutesValue_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_minutesValue_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hoursValue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_hoursValue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hoursValue_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hoursValue_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved2_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved2_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        countingType: u32,
        discontinuityFlag: u32,
        cntDroppedFrames: u32,
        nFrames: u32,
        secondsValue: u32,
        minutesValue: u32,
        hoursValue: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let countingType: u32 = unsafe { ::core::mem::transmute(countingType) };
            countingType as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let discontinuityFlag: u32 = unsafe { ::core::mem::transmute(discontinuityFlag) };
            discontinuityFlag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cntDroppedFrames: u32 = unsafe { ::core::mem::transmute(cntDroppedFrames) };
            cntDroppedFrames as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let nFrames: u32 = unsafe { ::core::mem::transmute(nFrames) };
            nFrames as u64
        });
        __bindgen_bitfield_unit.set(11usize, 6u8, {
            let secondsValue: u32 = unsafe { ::core::mem::transmute(secondsValue) };
            secondsValue as u64
        });
        __bindgen_bitfield_unit.set(17usize, 6u8, {
            let minutesValue: u32 = unsafe { ::core::mem::transmute(minutesValue) };
            minutesValue as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let hoursValue: u32 = unsafe { ::core::mem::transmute(hoursValue) };
            hoursValue as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_TIME_CODE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _HEVC_3D_REFERENCE_DISPLAY_INFO {
    #[inline]
    pub fn refViewingDistanceFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_refViewingDistanceFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn refViewingDistanceFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_refViewingDistanceFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn threeDimensionalReferenceDisplaysExtensionFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_threeDimensionalReferenceDisplaysExtensionFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn threeDimensionalReferenceDisplaysExtensionFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_threeDimensionalReferenceDisplaysExtensionFlag_raw(
        this: *mut Self,
        val: u32,
    ) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        refViewingDistanceFlag: u32,
        threeDimensionalReferenceDisplaysExtensionFlag: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let refViewingDistanceFlag: u32 =
                unsafe { ::core::mem::transmute(refViewingDistanceFlag) };
            refViewingDistanceFlag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let threeDimensionalReferenceDisplaysExtensionFlag: u32 =
                unsafe { ::core::mem::transmute(threeDimensionalReferenceDisplaysExtensionFlag) };
            threeDimensionalReferenceDisplaysExtensionFlag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_CONFIG_H264_VUI_PARAMETERS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    #[inline]
    pub fn numCandsPerBlk16x16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCandsPerBlk16x16_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCandsPerBlk16x16_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCandsPerBlk16x8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCandsPerBlk16x8_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCandsPerBlk16x8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCandsPerBlk8x16_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCandsPerBlk8x16_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCandsPerBlk8x8_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCandsPerBlk8x8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCandsPerSb(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerSb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCandsPerSb_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCandsPerSb_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        numCandsPerBlk16x16: u32,
        numCandsPerBlk16x8: u32,
        numCandsPerBlk8x16: u32,
        numCandsPerBlk8x8: u32,
        numCandsPerSb: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let numCandsPerBlk16x16: u32 = unsafe { ::core::mem::transmute(numCandsPerBlk16x16) };
            numCandsPerBlk16x16 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let numCandsPerBlk16x8: u32 = unsafe { ::core::mem::transmute(numCandsPerBlk16x8) };
            numCandsPerBlk16x8 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let numCandsPerBlk8x16: u32 = unsafe { ::core::mem::transmute(numCandsPerBlk8x16) };
            numCandsPerBlk8x16 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let numCandsPerBlk8x8: u32 = unsafe { ::core::mem::transmute(numCandsPerBlk8x8) };
            numCandsPerBlk8x8 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let numCandsPerSb: u32 = unsafe { ::core::mem::transmute(numCandsPerSb) };
            numCandsPerSb as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _NVENC_EXTERNAL_ME_HINT {
    #[inline]
    pub fn mvx(&self) -> i32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_mvx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mvx_raw(this: *const Self) -> i32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mvx_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mvy(&self) -> i32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_mvy(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mvy_raw(this: *const Self) -> i32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mvy_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn refidx(&self) -> i32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_refidx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn refidx_raw(this: *const Self) -> i32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_refidx_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dir(&self) -> i32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dir(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dir_raw(this: *const Self) -> i32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dir_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn partType(&self) -> i32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_partType(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn partType_raw(this: *const Self) -> i32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_partType_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lastofPart(&self) -> i32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastofPart(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lastofPart_raw(this: *const Self) -> i32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lastofPart_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lastOfMB(&self) -> i32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastOfMB(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lastOfMB_raw(this: *const Self) -> i32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lastOfMB_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mvx: i32,
        mvy: i32,
        refidx: i32,
        dir: i32,
        partType: i32,
        lastofPart: i32,
        lastOfMB: i32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let mvx: u32 = unsafe { ::core::mem::transmute(mvx) };
            mvx as u64
        });
        __bindgen_bitfield_unit.set(12usize, 10u8, {
            let mvy: u32 = unsafe { ::core::mem::transmute(mvy) };
            mvy as u64
        });
        __bindgen_bitfield_unit.set(22usize, 5u8, {
            let refidx: u32 = unsafe { ::core::mem::transmute(refidx) };
            refidx as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let dir: u32 = unsafe { ::core::mem::transmute(dir) };
            dir as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let partType: u32 = unsafe { ::core::mem::transmute(partType) };
            partType as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let lastofPart: u32 = unsafe { ::core::mem::transmute(lastofPart) };
            lastofPart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lastOfMB: u32 = unsafe { ::core::mem::transmute(lastOfMB) };
            lastOfMB as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _NVENC_EXTERNAL_ME_SB_HINT {
    #[inline]
    pub fn refidx(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_refidx(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn refidx_raw(this: *const Self) -> i16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_refidx_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn direction(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_direction(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn direction_raw(this: *const Self) -> i16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_direction_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bi(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_bi(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bi_raw(this: *const Self) -> i16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_bi_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn partition_type(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_partition_type(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn partition_type_raw(this: *const Self) -> i16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_partition_type_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn x8(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_x8(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn x8_raw(this: *const Self) -> i16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_x8_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn last_of_cu(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_last_of_cu(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn last_of_cu_raw(this: *const Self) -> i16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_last_of_cu_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn last_of_sb(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_last_of_sb(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn last_of_sb_raw(this: *const Self) -> i16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_last_of_sb_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved0(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved0_raw(this: *const Self) -> i16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_reserved0_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mvx(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_mvx(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mvx_raw(this: *const Self) -> i16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                14u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_mvx_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                14u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cu_size(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_cu_size(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cu_size_raw(this: *const Self) -> i16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_cu_size_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mvy(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_mvy(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mvy_raw(this: *const Self) -> i16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                12u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_mvy_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn y8(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_y8(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn y8_raw(this: *const Self) -> i16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                44usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_y8_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved1(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved1_raw(this: *const Self) -> i16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                47usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_reserved1_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                47usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        refidx: i16,
        direction: i16,
        bi: i16,
        partition_type: i16,
        x8: i16,
        last_of_cu: i16,
        last_of_sb: i16,
        reserved0: i16,
        mvx: i16,
        cu_size: i16,
        mvy: i16,
        y8: i16,
        reserved1: i16,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let refidx: u16 = unsafe { ::core::mem::transmute(refidx) };
            refidx as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let direction: u16 = unsafe { ::core::mem::transmute(direction) };
            direction as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bi: u16 = unsafe { ::core::mem::transmute(bi) };
            bi as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let partition_type: u16 = unsafe { ::core::mem::transmute(partition_type) };
            partition_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let x8: u16 = unsafe { ::core::mem::transmute(x8) };
            x8 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let last_of_cu: u16 = unsafe { ::core::mem::transmute(last_of_cu) };
            last_of_cu as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let last_of_sb: u16 = unsafe { ::core::mem::transmute(last_of_sb) };
            last_of_sb as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved0: u16 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 14u8, {
            let mvx: u16 = unsafe { ::core::mem::transmute(mvx) };
            mvx as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let cu_size: u16 = unsafe { ::core::mem::transmute(cu_size) };
            cu_size as u64
        });
        __bindgen_bitfield_unit.set(32usize, 12u8, {
            let mvy: u16 = unsafe { ::core::mem::transmute(mvy) };
            mvy as u64
        });
        __bindgen_bitfield_unit.set(44usize, 3u8, {
            let y8: u16 = unsafe { ::core::mem::transmute(y8) };
            y8 as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let reserved1: u16 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_CONFIG_H264 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_H264 {
    #[inline]
    pub fn enableTemporalSVC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalSVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableTemporalSVC_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableTemporalSVC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableStereoMVC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableStereoMVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableStereoMVC_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableStereoMVC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hierarchicalPFrames(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalPFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hierarchicalPFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hierarchicalPFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hierarchicalBFrames(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalBFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hierarchicalBFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hierarchicalBFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputBufferingPeriodSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputBufferingPeriodSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputPictureTimingSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputPictureTimingSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputAUD_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputAUD_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableSPSPPS_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableSPSPPS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputFramePackingSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputFramePackingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputFramePackingSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputFramePackingSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputRecoveryPointSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputRecoveryPointSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputRecoveryPointSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputRecoveryPointSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableIntraRefresh_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableIntraRefresh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableConstrainedEncoding(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableConstrainedEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableConstrainedEncoding_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableConstrainedEncoding_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn repeatSPSPPS_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_repeatSPSPPS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableVFR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableVFR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableVFR_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableVFR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableLTR_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableLTR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn qpPrimeYZeroTransformBypassFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_qpPrimeYZeroTransformBypassFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qpPrimeYZeroTransformBypassFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_qpPrimeYZeroTransformBypassFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn useConstrainedIntraPred_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_useConstrainedIntraPred_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableFillerDataInsertion(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFillerDataInsertion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableFillerDataInsertion_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableFillerDataInsertion_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableSVCPrefixNalu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSVCPrefixNalu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableSVCPrefixNalu_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableSVCPrefixNalu_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableScalabilityInfoSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableScalabilityInfoSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableScalabilityInfoSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableScalabilityInfoSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn singleSliceIntraRefresh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_singleSliceIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn singleSliceIntraRefresh_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_singleSliceIntraRefresh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableTimeCode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTimeCode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableTimeCode_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableTimeCode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableTemporalSVC: u32,
        enableStereoMVC: u32,
        hierarchicalPFrames: u32,
        hierarchicalBFrames: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        disableSPSPPS: u32,
        outputFramePackingSEI: u32,
        outputRecoveryPointSEI: u32,
        enableIntraRefresh: u32,
        enableConstrainedEncoding: u32,
        repeatSPSPPS: u32,
        enableVFR: u32,
        enableLTR: u32,
        qpPrimeYZeroTransformBypassFlag: u32,
        useConstrainedIntraPred: u32,
        enableFillerDataInsertion: u32,
        disableSVCPrefixNalu: u32,
        enableScalabilityInfoSEI: u32,
        singleSliceIntraRefresh: u32,
        enableTimeCode: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableTemporalSVC: u32 = unsafe { ::core::mem::transmute(enableTemporalSVC) };
            enableTemporalSVC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableStereoMVC: u32 = unsafe { ::core::mem::transmute(enableStereoMVC) };
            enableStereoMVC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hierarchicalPFrames: u32 = unsafe { ::core::mem::transmute(hierarchicalPFrames) };
            hierarchicalPFrames as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hierarchicalBFrames: u32 = unsafe { ::core::mem::transmute(hierarchicalBFrames) };
            hierarchicalBFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::core::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::core::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let outputAUD: u32 = unsafe { ::core::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::core::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let outputFramePackingSEI: u32 =
                unsafe { ::core::mem::transmute(outputFramePackingSEI) };
            outputFramePackingSEI as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let outputRecoveryPointSEI: u32 =
                unsafe { ::core::mem::transmute(outputRecoveryPointSEI) };
            outputRecoveryPointSEI as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::core::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enableConstrainedEncoding: u32 =
                unsafe { ::core::mem::transmute(enableConstrainedEncoding) };
            enableConstrainedEncoding as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::core::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let enableVFR: u32 = unsafe { ::core::mem::transmute(enableVFR) };
            enableVFR as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableLTR: u32 = unsafe { ::core::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let qpPrimeYZeroTransformBypassFlag: u32 =
                unsafe { ::core::mem::transmute(qpPrimeYZeroTransformBypassFlag) };
            qpPrimeYZeroTransformBypassFlag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::core::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let enableFillerDataInsertion: u32 =
                unsafe { ::core::mem::transmute(enableFillerDataInsertion) };
            enableFillerDataInsertion as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let disableSVCPrefixNalu: u32 = unsafe { ::core::mem::transmute(disableSVCPrefixNalu) };
            disableSVCPrefixNalu as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let enableScalabilityInfoSEI: u32 =
                unsafe { ::core::mem::transmute(enableScalabilityInfoSEI) };
            enableScalabilityInfoSEI as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let singleSliceIntraRefresh: u32 =
                unsafe { ::core::mem::transmute(singleSliceIntraRefresh) };
            singleSliceIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let enableTimeCode: u32 = unsafe { ::core::mem::transmute(enableTimeCode) };
            enableTimeCode as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_CONFIG_HEVC {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_HEVC {
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn useConstrainedIntraPred_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_useConstrainedIntraPred_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableDeblockAcrossSliceBoundary(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableDeblockAcrossSliceBoundary(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableDeblockAcrossSliceBoundary_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableDeblockAcrossSliceBoundary_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputBufferingPeriodSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputBufferingPeriodSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputPictureTimingSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputPictureTimingSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputAUD_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputAUD_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableLTR_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableLTR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableSPSPPS_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableSPSPPS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn repeatSPSPPS_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_repeatSPSPPS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableIntraRefresh_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableIntraRefresh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn chromaFormatIDC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chromaFormatIDC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn chromaFormatIDC_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_chromaFormatIDC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved3_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved3_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableFillerDataInsertion(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFillerDataInsertion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableFillerDataInsertion_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableFillerDataInsertion_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableConstrainedEncoding(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableConstrainedEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableConstrainedEncoding_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableConstrainedEncoding_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableAlphaLayerEncoding(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAlphaLayerEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableAlphaLayerEncoding_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableAlphaLayerEncoding_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn singleSliceIntraRefresh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_singleSliceIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn singleSliceIntraRefresh_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_singleSliceIntraRefresh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputRecoveryPointSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputRecoveryPointSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputRecoveryPointSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputRecoveryPointSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputTimeCodeSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputTimeCodeSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputTimeCodeSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputTimeCodeSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableTemporalSVC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalSVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableTemporalSVC_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableTemporalSVC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableMVHEVC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMVHEVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableMVHEVC_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableMVHEVC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputHevc3DReferenceDisplayInfo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputHevc3DReferenceDisplayInfo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputHevc3DReferenceDisplayInfo_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputHevc3DReferenceDisplayInfo_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputMaxCll(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputMaxCll(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputMaxCll_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputMaxCll_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputMasteringDisplay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputMasteringDisplay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputMasteringDisplay_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputMasteringDisplay_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        useConstrainedIntraPred: u32,
        disableDeblockAcrossSliceBoundary: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        enableLTR: u32,
        disableSPSPPS: u32,
        repeatSPSPPS: u32,
        enableIntraRefresh: u32,
        chromaFormatIDC: u32,
        reserved3: u32,
        enableFillerDataInsertion: u32,
        enableConstrainedEncoding: u32,
        enableAlphaLayerEncoding: u32,
        singleSliceIntraRefresh: u32,
        outputRecoveryPointSEI: u32,
        outputTimeCodeSEI: u32,
        enableTemporalSVC: u32,
        enableMVHEVC: u32,
        outputHevc3DReferenceDisplayInfo: u32,
        outputMaxCll: u32,
        outputMasteringDisplay: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::core::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disableDeblockAcrossSliceBoundary: u32 =
                unsafe { ::core::mem::transmute(disableDeblockAcrossSliceBoundary) };
            disableDeblockAcrossSliceBoundary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::core::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::core::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputAUD: u32 = unsafe { ::core::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLTR: u32 = unsafe { ::core::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::core::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::core::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::core::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let chromaFormatIDC: u32 = unsafe { ::core::mem::transmute(chromaFormatIDC) };
            chromaFormatIDC as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableFillerDataInsertion: u32 =
                unsafe { ::core::mem::transmute(enableFillerDataInsertion) };
            enableFillerDataInsertion as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enableConstrainedEncoding: u32 =
                unsafe { ::core::mem::transmute(enableConstrainedEncoding) };
            enableConstrainedEncoding as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let enableAlphaLayerEncoding: u32 =
                unsafe { ::core::mem::transmute(enableAlphaLayerEncoding) };
            enableAlphaLayerEncoding as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let singleSliceIntraRefresh: u32 =
                unsafe { ::core::mem::transmute(singleSliceIntraRefresh) };
            singleSliceIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let outputRecoveryPointSEI: u32 =
                unsafe { ::core::mem::transmute(outputRecoveryPointSEI) };
            outputRecoveryPointSEI as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let outputTimeCodeSEI: u32 = unsafe { ::core::mem::transmute(outputTimeCodeSEI) };
            outputTimeCodeSEI as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let enableTemporalSVC: u32 = unsafe { ::core::mem::transmute(enableTemporalSVC) };
            enableTemporalSVC as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let enableMVHEVC: u32 = unsafe { ::core::mem::transmute(enableMVHEVC) };
            enableMVHEVC as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let outputHevc3DReferenceDisplayInfo: u32 =
                unsafe { ::core::mem::transmute(outputHevc3DReferenceDisplayInfo) };
            outputHevc3DReferenceDisplayInfo as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let outputMaxCll: u32 = unsafe { ::core::mem::transmute(outputMaxCll) };
            outputMaxCll as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let outputMasteringDisplay: u32 =
                unsafe { ::core::mem::transmute(outputMasteringDisplay) };
            outputMasteringDisplay as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _NV_ENC_FILM_GRAIN_PARAMS_AV1 {
    #[inline]
    pub fn applyGrain(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_applyGrain(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn applyGrain_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_applyGrain_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn chromaScalingFromLuma(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chromaScalingFromLuma(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn chromaScalingFromLuma_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_chromaScalingFromLuma_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn overlapFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overlapFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn overlapFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_overlapFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn clipToRestrictedRange(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clipToRestrictedRange(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn clipToRestrictedRange_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_clipToRestrictedRange_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn grainScalingMinus8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_grainScalingMinus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn grainScalingMinus8_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_grainScalingMinus8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn arCoeffLag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_arCoeffLag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn arCoeffLag_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_arCoeffLag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numYPoints(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numYPoints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numYPoints_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numYPoints_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCbPoints(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCbPoints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCbPoints_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCbPoints_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCrPoints(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCrPoints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCrPoints_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCrPoints_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn arCoeffShiftMinus6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_arCoeffShiftMinus6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn arCoeffShiftMinus6_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_arCoeffShiftMinus6_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn grainScaleShift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_grainScaleShift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn grainScaleShift_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_grainScaleShift_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved1_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        applyGrain: u32,
        chromaScalingFromLuma: u32,
        overlapFlag: u32,
        clipToRestrictedRange: u32,
        grainScalingMinus8: u32,
        arCoeffLag: u32,
        numYPoints: u32,
        numCbPoints: u32,
        numCrPoints: u32,
        arCoeffShiftMinus6: u32,
        grainScaleShift: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let applyGrain: u32 = unsafe { ::core::mem::transmute(applyGrain) };
            applyGrain as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let chromaScalingFromLuma: u32 =
                unsafe { ::core::mem::transmute(chromaScalingFromLuma) };
            chromaScalingFromLuma as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let overlapFlag: u32 = unsafe { ::core::mem::transmute(overlapFlag) };
            overlapFlag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let clipToRestrictedRange: u32 =
                unsafe { ::core::mem::transmute(clipToRestrictedRange) };
            clipToRestrictedRange as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let grainScalingMinus8: u32 = unsafe { ::core::mem::transmute(grainScalingMinus8) };
            grainScalingMinus8 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let arCoeffLag: u32 = unsafe { ::core::mem::transmute(arCoeffLag) };
            arCoeffLag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let numYPoints: u32 = unsafe { ::core::mem::transmute(numYPoints) };
            numYPoints as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let numCbPoints: u32 = unsafe { ::core::mem::transmute(numCbPoints) };
            numCbPoints as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let numCrPoints: u32 = unsafe { ::core::mem::transmute(numCrPoints) };
            numCrPoints as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let arCoeffShiftMinus6: u32 = unsafe { ::core::mem::transmute(arCoeffShiftMinus6) };
            arCoeffShiftMinus6 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let grainScaleShift: u32 = unsafe { ::core::mem::transmute(grainScaleShift) };
            grainScaleShift as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_CONFIG_AV1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_AV1 {
    #[inline]
    pub fn outputAnnexBFormat(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAnnexBFormat(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputAnnexBFormat_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputAnnexBFormat_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableTimingInfo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTimingInfo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableTimingInfo_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableTimingInfo_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableDecoderModelInfo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableDecoderModelInfo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableDecoderModelInfo_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableDecoderModelInfo_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableFrameIdNumbers(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFrameIdNumbers(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableFrameIdNumbers_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableFrameIdNumbers_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableSeqHdr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSeqHdr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableSeqHdr_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableSeqHdr_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn repeatSeqHdr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSeqHdr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn repeatSeqHdr_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_repeatSeqHdr_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableIntraRefresh_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableIntraRefresh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn chromaFormatIDC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chromaFormatIDC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn chromaFormatIDC_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_chromaFormatIDC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableBitstreamPadding(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableBitstreamPadding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableBitstreamPadding_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableBitstreamPadding_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableCustomTileConfig(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableCustomTileConfig(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableCustomTileConfig_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableCustomTileConfig_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableFilmGrainParams(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFilmGrainParams(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableFilmGrainParams_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableFilmGrainParams_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableLTR_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableLTR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableTemporalSVC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalSVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableTemporalSVC_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableTemporalSVC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputMaxCll(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputMaxCll(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputMaxCll_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputMaxCll_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputMasteringDisplay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputMasteringDisplay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputMasteringDisplay_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputMasteringDisplay_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved4_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved4_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                14u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                14u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        outputAnnexBFormat: u32,
        enableTimingInfo: u32,
        enableDecoderModelInfo: u32,
        enableFrameIdNumbers: u32,
        disableSeqHdr: u32,
        repeatSeqHdr: u32,
        enableIntraRefresh: u32,
        chromaFormatIDC: u32,
        enableBitstreamPadding: u32,
        enableCustomTileConfig: u32,
        enableFilmGrainParams: u32,
        enableLTR: u32,
        enableTemporalSVC: u32,
        outputMaxCll: u32,
        outputMasteringDisplay: u32,
        reserved4: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let outputAnnexBFormat: u32 = unsafe { ::core::mem::transmute(outputAnnexBFormat) };
            outputAnnexBFormat as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableTimingInfo: u32 = unsafe { ::core::mem::transmute(enableTimingInfo) };
            enableTimingInfo as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableDecoderModelInfo: u32 =
                unsafe { ::core::mem::transmute(enableDecoderModelInfo) };
            enableDecoderModelInfo as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableFrameIdNumbers: u32 = unsafe { ::core::mem::transmute(enableFrameIdNumbers) };
            enableFrameIdNumbers as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disableSeqHdr: u32 = unsafe { ::core::mem::transmute(disableSeqHdr) };
            disableSeqHdr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let repeatSeqHdr: u32 = unsafe { ::core::mem::transmute(repeatSeqHdr) };
            repeatSeqHdr as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::core::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let chromaFormatIDC: u32 = unsafe { ::core::mem::transmute(chromaFormatIDC) };
            chromaFormatIDC as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let enableBitstreamPadding: u32 =
                unsafe { ::core::mem::transmute(enableBitstreamPadding) };
            enableBitstreamPadding as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableCustomTileConfig: u32 =
                unsafe { ::core::mem::transmute(enableCustomTileConfig) };
            enableCustomTileConfig as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enableFilmGrainParams: u32 =
                unsafe { ::core::mem::transmute(enableFilmGrainParams) };
            enableFilmGrainParams as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let enableLTR: u32 = unsafe { ::core::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let enableTemporalSVC: u32 = unsafe { ::core::mem::transmute(enableTemporalSVC) };
            enableTemporalSVC as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let outputMaxCll: u32 = unsafe { ::core::mem::transmute(outputMaxCll) };
            outputMaxCll as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let outputMasteringDisplay: u32 =
                unsafe { ::core::mem::transmute(outputMasteringDisplay) };
            outputMasteringDisplay as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_CONFIG_H264_MEONLY {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_H264_MEONLY {
    #[inline]
    pub fn disablePartition16x16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disablePartition16x16_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disablePartition16x16_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disablePartition8x16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disablePartition8x16_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disablePartition8x16_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disablePartition16x8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disablePartition16x8_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disablePartition16x8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disablePartition8x8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disablePartition8x8_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disablePartition8x8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableIntraSearch(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIntraSearch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableIntraSearch_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableIntraSearch_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bStereoEnable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bStereoEnable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bStereoEnable_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bStereoEnable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                26u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                26u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disablePartition16x16: u32,
        disablePartition8x16: u32,
        disablePartition16x8: u32,
        disablePartition8x8: u32,
        disableIntraSearch: u32,
        bStereoEnable: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disablePartition16x16: u32 =
                unsafe { ::core::mem::transmute(disablePartition16x16) };
            disablePartition16x16 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disablePartition8x16: u32 = unsafe { ::core::mem::transmute(disablePartition8x16) };
            disablePartition8x16 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disablePartition16x8: u32 = unsafe { ::core::mem::transmute(disablePartition16x8) };
            disablePartition16x8 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let disablePartition8x8: u32 = unsafe { ::core::mem::transmute(disablePartition8x8) };
            disablePartition8x8 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disableIntraSearch: u32 = unsafe { ::core::mem::transmute(disableIntraSearch) };
            disableIntraSearch as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bStereoEnable: u32 = unsafe { ::core::mem::transmute(bStereoEnable) };
            bStereoEnable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_CONFIG_HEVC_MEONLY {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_CODEC_CONFIG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_CONFIG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_INITIALIZE_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_INITIALIZE_PARAMS {
    #[inline]
    pub fn reportSliceOffsets(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reportSliceOffsets(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reportSliceOffsets_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reportSliceOffsets_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableSubFrameWrite(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableSubFrameWrite(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableSubFrameWrite_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableSubFrameWrite_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableExternalMEHints(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableExternalMEHints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableExternalMEHints_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableExternalMEHints_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableMEOnlyMode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMEOnlyMode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableMEOnlyMode_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableMEOnlyMode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableWeightedPrediction(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableWeightedPrediction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableWeightedPrediction_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableWeightedPrediction_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn splitEncodeMode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_splitEncodeMode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn splitEncodeMode_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_splitEncodeMode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableOutputInVidmem(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableOutputInVidmem(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableOutputInVidmem_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableOutputInVidmem_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableReconFrameOutput(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableReconFrameOutput(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableReconFrameOutput_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableReconFrameOutput_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableOutputStats(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableOutputStats(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableOutputStats_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableOutputStats_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableUniDirectionalB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableUniDirectionalB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableUniDirectionalB_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableUniDirectionalB_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                19u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                19u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reportSliceOffsets: u32,
        enableSubFrameWrite: u32,
        enableExternalMEHints: u32,
        enableMEOnlyMode: u32,
        enableWeightedPrediction: u32,
        splitEncodeMode: u32,
        enableOutputInVidmem: u32,
        enableReconFrameOutput: u32,
        enableOutputStats: u32,
        enableUniDirectionalB: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reportSliceOffsets: u32 = unsafe { ::core::mem::transmute(reportSliceOffsets) };
            reportSliceOffsets as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableSubFrameWrite: u32 = unsafe { ::core::mem::transmute(enableSubFrameWrite) };
            enableSubFrameWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableExternalMEHints: u32 =
                unsafe { ::core::mem::transmute(enableExternalMEHints) };
            enableExternalMEHints as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableMEOnlyMode: u32 = unsafe { ::core::mem::transmute(enableMEOnlyMode) };
            enableMEOnlyMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enableWeightedPrediction: u32 =
                unsafe { ::core::mem::transmute(enableWeightedPrediction) };
            enableWeightedPrediction as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let splitEncodeMode: u32 = unsafe { ::core::mem::transmute(splitEncodeMode) };
            splitEncodeMode as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let enableOutputInVidmem: u32 = unsafe { ::core::mem::transmute(enableOutputInVidmem) };
            enableOutputInVidmem as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableReconFrameOutput: u32 =
                unsafe { ::core::mem::transmute(enableReconFrameOutput) };
            enableReconFrameOutput as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enableOutputStats: u32 = unsafe { ::core::mem::transmute(enableOutputStats) };
            enableOutputStats as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let enableUniDirectionalB: u32 =
                unsafe { ::core::mem::transmute(enableUniDirectionalB) };
            enableUniDirectionalB as u64
        });
        __bindgen_bitfield_unit.set(13usize, 19u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_RECONFIGURE_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_RECONFIGURE_PARAMS {
    #[inline]
    pub fn resetEncoder(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resetEncoder(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn resetEncoder_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_resetEncoder_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn forceIDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceIDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn forceIDR_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_forceIDR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved1_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        resetEncoder: u32,
        forceIDR: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let resetEncoder: u32 = unsafe { ::core::mem::transmute(resetEncoder) };
            resetEncoder as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let forceIDR: u32 = unsafe { ::core::mem::transmute(forceIDR) };
            forceIDR as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_PRESET_CONFIG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_PIC_PARAMS_MVC {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_PIC_PARAMS_H264_EXT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_SEI_PAYLOAD {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_PIC_PARAMS_H264 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_PIC_PARAMS_H264 {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn constrainedFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_constrainedFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sliceModeDataUpdate_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sliceModeDataUpdate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrMarkFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrMarkFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrUseFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrUseFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::core::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::core::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::core::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::core::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_PIC_PARAMS_HEVC {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_PIC_PARAMS_HEVC {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn constrainedFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_constrainedFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sliceModeDataUpdate_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sliceModeDataUpdate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrMarkFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrMarkFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrUseFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrUseFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn temporalConfigUpdate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temporalConfigUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn temporalConfigUpdate_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_temporalConfigUpdate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                27u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                27u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        temporalConfigUpdate: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::core::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::core::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::core::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::core::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let temporalConfigUpdate: u32 = unsafe { ::core::mem::transmute(temporalConfigUpdate) };
            temporalConfigUpdate as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_PIC_PARAMS_AV1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_PIC_PARAMS_AV1 {
    #[inline]
    pub fn goldenFrameFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_goldenFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn goldenFrameFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_goldenFrameFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn arfFrameFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_arfFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn arfFrameFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_arfFrameFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn arf2FrameFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_arf2FrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn arf2FrameFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_arf2FrameFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bwdFrameFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bwdFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bwdFrameFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bwdFrameFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn overlayFrameFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overlayFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn overlayFrameFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_overlayFrameFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn showExistingFrameFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_showExistingFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn showExistingFrameFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_showExistingFrameFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn errorResilientModeFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_errorResilientModeFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn errorResilientModeFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_errorResilientModeFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tileConfigUpdate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tileConfigUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tileConfigUpdate_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tileConfigUpdate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableCustomTileConfig(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableCustomTileConfig(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableCustomTileConfig_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableCustomTileConfig_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn filmGrainParamsUpdate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filmGrainParamsUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn filmGrainParamsUpdate_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_filmGrainParamsUpdate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrMarkFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrMarkFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrUseFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrUseFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn temporalConfigUpdate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temporalConfigUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn temporalConfigUpdate_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_temporalConfigUpdate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                19u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                19u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        goldenFrameFlag: u32,
        arfFrameFlag: u32,
        arf2FrameFlag: u32,
        bwdFrameFlag: u32,
        overlayFrameFlag: u32,
        showExistingFrameFlag: u32,
        errorResilientModeFlag: u32,
        tileConfigUpdate: u32,
        enableCustomTileConfig: u32,
        filmGrainParamsUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        temporalConfigUpdate: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let goldenFrameFlag: u32 = unsafe { ::core::mem::transmute(goldenFrameFlag) };
            goldenFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let arfFrameFlag: u32 = unsafe { ::core::mem::transmute(arfFrameFlag) };
            arfFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let arf2FrameFlag: u32 = unsafe { ::core::mem::transmute(arf2FrameFlag) };
            arf2FrameFlag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bwdFrameFlag: u32 = unsafe { ::core::mem::transmute(bwdFrameFlag) };
            bwdFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let overlayFrameFlag: u32 = unsafe { ::core::mem::transmute(overlayFrameFlag) };
            overlayFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let showExistingFrameFlag: u32 =
                unsafe { ::core::mem::transmute(showExistingFrameFlag) };
            showExistingFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let errorResilientModeFlag: u32 =
                unsafe { ::core::mem::transmute(errorResilientModeFlag) };
            errorResilientModeFlag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tileConfigUpdate: u32 = unsafe { ::core::mem::transmute(tileConfigUpdate) };
            tileConfigUpdate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableCustomTileConfig: u32 =
                unsafe { ::core::mem::transmute(enableCustomTileConfig) };
            enableCustomTileConfig as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let filmGrainParamsUpdate: u32 =
                unsafe { ::core::mem::transmute(filmGrainParamsUpdate) };
            filmGrainParamsUpdate as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::core::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::core::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let temporalConfigUpdate: u32 = unsafe { ::core::mem::transmute(temporalConfigUpdate) };
            temporalConfigUpdate as u64
        });
        __bindgen_bitfield_unit.set(13usize, 19u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_CODEC_PIC_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_PIC_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_MEONLY_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_LOCK_BITSTREAM {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_LOCK_BITSTREAM {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn doNotWait_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_doNotWait_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrFrame(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn getRCStats(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_getRCStats(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn getRCStats_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_getRCStats_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        ltrFrame: u32,
        getRCStats: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::core::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ltrFrame: u32 = unsafe { ::core::mem::transmute(ltrFrame) };
            ltrFrame as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let getRCStats: u32 = unsafe { ::core::mem::transmute(getRCStats) };
            getRCStats as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_LOCK_INPUT_BUFFER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_LOCK_INPUT_BUFFER {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn doNotWait_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_doNotWait_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::core::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_MAP_INPUT_RESOURCE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_FENCE_POINT_D3D12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_FENCE_POINT_D3D12 {
    #[inline]
    pub fn bWait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bWait_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bWait_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bSignal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSignal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bSignal_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bSignal_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitField(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitField(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitField_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitField_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bWait: u32,
        bSignal: u32,
        reservedBitField: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bWait: u32 = unsafe { ::core::mem::transmute(bWait) };
            bWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bSignal: u32 = unsafe { ::core::mem::transmute(bSignal) };
            bSignal as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reservedBitField: u32 = unsafe { ::core::mem::transmute(reservedBitField) };
            reservedBitField as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_INPUT_RESOURCE_D3D12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_OUTPUT_RESOURCE_D3D12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_REGISTER_RESOURCE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_STAT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_STAT {
    #[inline]
    pub fn ltrFrame(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ltrFrame: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ltrFrame: u32 = unsafe { ::core::mem::transmute(ltrFrame) };
            ltrFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_SEQUENCE_PARAM_PAYLOAD {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_EVENT_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENCODE_API_FUNCTION_LIST {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub use self::_NVENCSTATUS as NVENCSTATUS;
pub use self::_NV_ENC_AV1_PART_SIZE as NV_ENC_AV1_PART_SIZE;
pub use self::_NV_ENC_BFRAME_REF_MODE as NV_ENC_BFRAME_REF_MODE;
pub use self::_NV_ENC_BIT_DEPTH as NV_ENC_BIT_DEPTH;
pub use self::_NV_ENC_BUFFER_FORMAT as NV_ENC_BUFFER_FORMAT;
pub use self::_NV_ENC_BUFFER_USAGE as NV_ENC_BUFFER_USAGE;
pub use self::_NV_ENC_CAPS as NV_ENC_CAPS;
pub use self::_NV_ENC_DEVICE_TYPE as NV_ENC_DEVICE_TYPE;
pub use self::_NV_ENC_DISPLAY_PIC_STRUCT as NV_ENC_DISPLAY_PIC_STRUCT;
pub use self::_NV_ENC_EMPHASIS_MAP_LEVEL as NV_ENC_EMPHASIS_MAP_LEVEL;
pub use self::_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE as NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE;
pub use self::_NV_ENC_H264_BDIRECT_MODE as NV_ENC_H264_BDIRECT_MODE;
pub use self::_NV_ENC_H264_ENTROPY_CODING_MODE as NV_ENC_H264_ENTROPY_CODING_MODE;
pub use self::_NV_ENC_H264_FMO_MODE as NV_ENC_H264_FMO_MODE;
pub use self::_NV_ENC_HEVC_CUSIZE as NV_ENC_HEVC_CUSIZE;
pub use self::_NV_ENC_INPUT_RESOURCE_TYPE as NV_ENC_INPUT_RESOURCE_TYPE;
pub use self::_NV_ENC_LEVEL as NV_ENC_LEVEL;
pub use self::_NV_ENC_LOOKAHEAD_LEVEL as NV_ENC_LOOKAHEAD_LEVEL;
pub use self::_NV_ENC_MEMORY_HEAP as NV_ENC_MEMORY_HEAP;
pub use self::_NV_ENC_MULTI_PASS as NV_ENC_MULTI_PASS;
pub use self::_NV_ENC_MV_PRECISION as NV_ENC_MV_PRECISION;
pub use self::_NV_ENC_NUM_REF_FRAMES as NV_ENC_NUM_REF_FRAMES;
pub use self::_NV_ENC_OUTPUT_STATS_LEVEL as NV_ENC_OUTPUT_STATS_LEVEL;
pub use self::_NV_ENC_PARAMS_FRAME_FIELD_MODE as NV_ENC_PARAMS_FRAME_FIELD_MODE;
pub use self::_NV_ENC_PARAMS_RC_MODE as NV_ENC_PARAMS_RC_MODE;
pub use self::_NV_ENC_PIC_FLAGS as NV_ENC_PIC_FLAGS;
pub use self::_NV_ENC_PIC_STRUCT as NV_ENC_PIC_STRUCT;
pub use self::_NV_ENC_PIC_TYPE as NV_ENC_PIC_TYPE;
pub use self::_NV_ENC_QP_MAP_MODE as NV_ENC_QP_MAP_MODE;
pub use self::_NV_ENC_SPLIT_ENCODE_MODE as NV_ENC_SPLIT_ENCODE_MODE;
pub use self::_NV_ENC_STATE_RESTORE_TYPE as NV_ENC_STATE_RESTORE_TYPE;
pub use self::_NV_ENC_STEREO_PACKING_MODE as NV_ENC_STEREO_PACKING_MODE;
pub use self::_NV_ENC_TEMPORAL_FILTER_LEVEL as NV_ENC_TEMPORAL_FILTER_LEVEL;
pub use self::_NV_ENC_VUI_COLOR_PRIMARIES as NV_ENC_VUI_COLOR_PRIMARIES;
pub use self::_NV_ENC_VUI_MATRIX_COEFFS as NV_ENC_VUI_MATRIX_COEFFS;
pub use self::_NV_ENC_VUI_TRANSFER_CHARACTERISTIC as NV_ENC_VUI_TRANSFER_CHARACTERISTIC;
pub use self::_NV_ENC_VUI_VIDEO_FORMAT as NV_ENC_VUI_VIDEO_FORMAT;
unsafe extern "C" {
    #[must_use]
    pub fn NvEncOpenEncodeSession(
        device: *mut ::core::ffi::c_void,
        deviceType: u32,
        encoder: *mut *mut ::core::ffi::c_void,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodeGUIDCount(
        encoder: *mut ::core::ffi::c_void,
        encodeGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodeGUIDs(
        encoder: *mut ::core::ffi::c_void,
        GUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodeProfileGUIDCount(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        encodeProfileGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodeProfileGUIDs(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        profileGUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetInputFormatCount(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetInputFormats(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        inputFmts: *mut NV_ENC_BUFFER_FORMAT,
        inputFmtArraySize: u32,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodeCaps(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        capsParam: *mut NV_ENC_CAPS_PARAM,
        capsVal: *mut ::core::ffi::c_int,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodePresetCount(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodePresetGUIDs(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        presetGUIDs: *mut GUID,
        guidArraySize: u32,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodePresetConfig(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodePresetConfigEx(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        tuningInfo: NV_ENC_TUNING_INFO,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncInitializeEncoder(
        encoder: *mut ::core::ffi::c_void,
        createEncodeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncCreateInputBuffer(
        encoder: *mut ::core::ffi::c_void,
        createInputBufferParams: *mut NV_ENC_CREATE_INPUT_BUFFER,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncDestroyInputBuffer(
        encoder: *mut ::core::ffi::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncSetIOCudaStreams(
        encoder: *mut ::core::ffi::c_void,
        inputStream: NV_ENC_CUSTREAM_PTR,
        outputStream: NV_ENC_CUSTREAM_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncCreateBitstreamBuffer(
        encoder: *mut ::core::ffi::c_void,
        createBitstreamBufferParams: *mut NV_ENC_CREATE_BITSTREAM_BUFFER,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncDestroyBitstreamBuffer(
        encoder: *mut ::core::ffi::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncEncodePicture(
        encoder: *mut ::core::ffi::c_void,
        encodePicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncLockBitstream(
        encoder: *mut ::core::ffi::c_void,
        lockBitstreamBufferParams: *mut NV_ENC_LOCK_BITSTREAM,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncUnlockBitstream(
        encoder: *mut ::core::ffi::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncRestoreEncoderState(
        encoder: *mut ::core::ffi::c_void,
        restoreState: *mut NV_ENC_RESTORE_ENCODER_STATE_PARAMS,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncLockInputBuffer(
        encoder: *mut ::core::ffi::c_void,
        lockInputBufferParams: *mut NV_ENC_LOCK_INPUT_BUFFER,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncUnlockInputBuffer(
        encoder: *mut ::core::ffi::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodeStats(
        encoder: *mut ::core::ffi::c_void,
        encodeStats: *mut NV_ENC_STAT,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetSequenceParams(
        encoder: *mut ::core::ffi::c_void,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetSequenceParamEx(
        encoder: *mut ::core::ffi::c_void,
        encInitParams: *mut NV_ENC_INITIALIZE_PARAMS,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncRegisterAsyncEvent(
        encoder: *mut ::core::ffi::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncUnregisterAsyncEvent(
        encoder: *mut ::core::ffi::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncMapInputResource(
        encoder: *mut ::core::ffi::c_void,
        mapInputResParams: *mut NV_ENC_MAP_INPUT_RESOURCE,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncUnmapInputResource(
        encoder: *mut ::core::ffi::c_void,
        mappedInputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncDestroyEncoder(encoder: *mut ::core::ffi::c_void) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncInvalidateRefFrames(
        encoder: *mut ::core::ffi::c_void,
        invalidRefFrameTimeStamp: u64,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncOpenEncodeSessionEx(
        openSessionExParams: *mut NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS,
        encoder: *mut *mut ::core::ffi::c_void,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncRegisterResource(
        encoder: *mut ::core::ffi::c_void,
        registerResParams: *mut NV_ENC_REGISTER_RESOURCE,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncUnregisterResource(
        encoder: *mut ::core::ffi::c_void,
        registeredResource: NV_ENC_REGISTERED_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncReconfigureEncoder(
        encoder: *mut ::core::ffi::c_void,
        reInitEncodeParams: *mut NV_ENC_RECONFIGURE_PARAMS,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncCreateMVBuffer(
        encoder: *mut ::core::ffi::c_void,
        createMVBufferParams: *mut NV_ENC_CREATE_MV_BUFFER,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncDestroyMVBuffer(
        encoder: *mut ::core::ffi::c_void,
        mvBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncRunMotionEstimationOnly(
        encoder: *mut ::core::ffi::c_void,
        meOnlyParams: *mut NV_ENC_MEONLY_PARAMS,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncodeAPIGetMaxSupportedVersion(version: *mut u32) -> NVENCSTATUS;
    pub fn NvEncGetLastErrorString(encoder: *mut ::core::ffi::c_void)
        -> *const ::core::ffi::c_char;
    #[must_use]
    pub fn NvEncLookaheadPicture(
        encoder: *mut ::core::ffi::c_void,
        lookaheadParamas: *mut NV_ENC_LOOKAHEAD_PIC_PARAMS,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncodeAPICreateInstance(functionList: *mut NV_ENCODE_API_FUNCTION_LIST)
        -> NVENCSTATUS;
}
